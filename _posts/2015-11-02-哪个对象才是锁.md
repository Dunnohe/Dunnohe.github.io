---
layout: post
title:  "哪个对象才是锁"
date:   2015-09-26 18:51:59
categories: jekyll update
---

#哪个对象才是锁

首先回顾背景知识：

- 对于实例同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前对象的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。

<pre>Class A{ 
	public static synchronized void write(boolean b){
  		isTrue = b;
	}
	public static synchronized boolean read(){
  	return isTrue;
	}
}</pre>


1. 线程1访问A.write(true)方法时，线程2能访问A.read()方法吗？
2. 线程1访问new A().write(false)方法时，线程2能访问new A().read()方法吗？
3. 线程1访问A.write(false)方法时，线程2能访问new A().read()方法吗？


<pre>
public synchronized void write(boolean b){
  isTrue = b;
}

public synchronized boolean read(){
  return isTrue;
}
</pre>


1. A a=new A(); 线程1访问a.write(false)方法，线程2能访问a.read()方法吗？
2. A a=new A(); A b=new A();线程1访问a.write(false)方法，线程2能访问b.read()方法吗？


线程1访问A.write()方法时，线程2能访问A.read()方法吗？不能，因为静态方法的锁都是A.Class对象,线程1拿到锁之后，线程2就拿不到锁了。

线程1访问new A().write()方法时，线程2能访问new A().read()方法吗？不能，原因同上。

线程1访问A.write()方法时，线程2能访问new A().read()方法吗？不能，原因同上

A a=new A(); 线程1访问a.write()方法，线程2能访问a.read()方法吗？不能，因为这两个方法的锁都是对象a，线程1拿到了锁，线程2就不能访问了。

A a=new A(); A b=new A();线程1访问a.write()方法，线程2能访问b.read()方法吗？可以，因为线程1拿到的是锁是 a,而线程2访问b.read()需要的是锁是b。

现在你应该明白了这句话，对于实例同步方法，锁是当前实例对象。对于静态同步方法，锁是当前对象的Class对象。




