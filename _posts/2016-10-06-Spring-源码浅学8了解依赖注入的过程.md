---
layout:     post
title:      "spring源码了解"
subtitle:   " \"8，了解依赖注入的过程器\""
date:       2016-10-06 14:54:00
author:     "Dunno"
header-img: "img/post-bg-2015.jpg"
tags:
    - Spring
---

# 目录

- <a href="#js">背景介绍</a>
- <a href="#dmlj">加载的入口</a>

# <a name="js">背景介绍</a>
<p>之前已经基本了解了IOC容器读取配置，并且解析成beandefinition同时向容器注册的过程了。那么spring是如何实现“依赖注入”的呢</p>

# <a name="dmlj">依赖注入的入口</a>

<p>首先，注意依赖注入的过程是用户第一次向IOC容器索要Bean时触发的，当然也有例外，也就是我们可以在BeanDefinition信息中通过控制lazy-init属性来让容器完成对Bean的预实例化。我们之前也学习到了spring使用的默认beanFactory是DefaultListableBeanFactory，获取bean的方法是使用BeanFactory中的getBean方法，那么我们先来看看DefaultListableBeanFactory的getBean的实现吧。</p>

## 1,DefaultListableBeanFactory中getBean方法的实现
<p>这段代码向我们展现了容器获取bean的逻辑。</p>
<pre>
<code>

public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
		@Override
	public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException {
		return getBean(requiredType, (Object[]) null);
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException {
		Assert.notNull(requiredType, &quot;Required type must not be null&quot;);
		
		//根据给定的type类型获取候选的beanName名单
		String[] candidateNames = getBeanNamesForType(requiredType);

		//从候选名单中过滤出可以容器中含有且可以被注入的
		if (candidateNames.length &gt; 1) {
			List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length);
			for (String beanName : candidateNames) {
				if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
					autowireCandidates.add(beanName);
				}
			}
			if (autowireCandidates.size() &gt; 0) {
				candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);
			}
		}

		//如果过滤后的候选名单只有一个的话，则直接调用父类（AbstractBeanFactory的getBean方法获得对象）
		if (candidateNames.length == 1) {
			return getBean(candidateNames[0], requiredType, args);
		}
		//如果过滤后的候选名单只有多个的话
		else if (candidateNames.length &gt; 1) {
			Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;();
			for (String beanName : candidateNames) {
				candidates.put(beanName, getBean(beanName, requiredType, args));
			}
			//选择主要的侯选者作为返回
			String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
			if (primaryCandidate != null) {
				return (T) candidates.get(primaryCandidate);
			}
			//如果主要的侯选者为空，则选择最高优先级的bean作为返回，这个优先级是基于实现org.springframework.core.Ordered的getOrder的方法的。
			String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
			if (priorityCandidate != null) {
				return (T) candidates.get(priorityCandidate);
			}
			throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
		}

		BeanFactory parent = getParentBeanFactory();
		if (parent != null) {
			return parent.getBean(arequiredType, args);
		}
		throw new NoSuchBeanDefinitionException(requiredType);
	}
}
</code>
</pre>

## 2,AbstractBeanFactory中getBean方法的实现
<p>上面那段代码向我们展示了容器是如何筛选bean的，下面这段代码将展示容器去获取bean的具体逻辑</p>
<pre>
<code>
public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory {
@Override
	public Object getBean(String name) throws BeansException {
		return doGetBean(name, null, null, false);
	}

	@Override
	public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException {
		return doGetBean(name, requiredType, null, false);
	}

	@Override
	public Object getBean(String name, Object... args) throws BeansException {
		return doGetBean(name, null, args, false);
	}

	/**
	 * Return an instance, which may be shared or independent, of the specified bean.
	 * @param name the name of the bean to retrieve
	 * @param requiredType the required type of the bean to retrieve
	 * @param args arguments to use when creating a bean instance using explicit arguments
	 * (only applied when creating a new instance as opposed to retrieving an existing one)
	 * @return an instance of the bean
	 * @throws BeansException if the bean could not be created
	 */
	public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException {
		return doGetBean(name, requiredType, args, false);
	}

	/**
	 * Return an instance, which may be shared or independent, of the specified bean.
	 * @param name the name of the bean to retrieve
	 * @param requiredType the required type of the bean to retrieve
	 * @param args arguments to use when creating a bean instance using explicit arguments
	 * (only applied when creating a new instance as opposed to retrieving an existing one)
	 * @param typeCheckOnly whether the instance is obtained for a type check,
	 * not for actual use
	 * @return an instance of the bean
	 * @throws BeansException if the bean could not be created
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected &lt;T&gt; T doGetBean(
			final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)
			throws BeansException {

		final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isDebugEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.debug(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName +
							&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;);
				}
				else {
					logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// Fail if we&#x27;re already creating this bean instance:
			// We&#x27;re assumably within a circular reference.
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				String nameToLookup = originalBeanName(name);
				if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else {
					// No args -&gt; delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
			}

			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dependsOnBean : dependsOn) {
						if (isDependent(beanName, dependsOnBean)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dependsOnBean + &quot;&#x27;&quot;);
						}
						registerDependentBean(dependsOnBean, beanName);
						getBean(dependsOnBean);
					}
				}

				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// It&#x27;s a prototype -&gt; create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);
					}
					try {
						Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {
							@Override
							public Object getObject() throws BeansException {
								beforePrototypeCreation(beanName);
								try {
									return createBean(beanName, mbd, args);
								}
								finally {
									afterPrototypeCreation(beanName);
								}
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								&quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +
								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) {
			try {
				return getTypeConverter().convertIfNecessary(bean, requiredType);
			}
			catch (TypeMismatchException ex) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type [&quot; +
							ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
}
</code>
</pre>


