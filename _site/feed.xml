<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io//</link>
    <atom:link href="http://dunnohe.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 04 May 2016 09:59:32 +0800</pubDate>
    <lastBuildDate>Wed, 04 May 2016 09:59:32 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>Java多线程学习6 Reentrantlock</title>
        <description>&lt;h1 id=&quot;java6-reentrantlock&quot;&gt;Java多线程学习6-ReentrantLock(可重入锁)&lt;/h1&gt;
&lt;p&gt;[toc]
# 介绍
重入锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个ReentrantLock的拥有者是最近一次使用该锁lock了却还没有unlock的线程。&lt;/li&gt;
  &lt;li&gt;如果一个线程成功的lock了，方法会成功返回，同时该线程会获得锁。如果该线程已经拥有该锁，再调用lock方法，lock方法会立马返回。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重要的方法&lt;/p&gt;

&lt;p&gt;public void lock()&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得锁
    &lt;ul&gt;
      &lt;li&gt;如果该锁没有被其他的线程持有，则该方法会立马返回，调用该方法的线程持有该锁，并且lock hold count(锁持有数)设置成1。&lt;/li&gt;
      &lt;li&gt;如果该线程已经拥有该锁，则该方法立马返回，且lock hold count（锁持有数）增加1。&lt;/li&gt;
      &lt;li&gt;如果该锁已经被其他线程持有，那么当前线程将会block直到获得该锁。获得的那个时候lock hold count（锁持有数）会被设置成1。（可以说明该锁是“独占的”，不同线程只能有一个线程占有）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public void lockInterruptibly() throws InterruptedException&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得锁除非当前线程被打断
    &lt;ul&gt;
      &lt;li&gt;如果该锁没有被其他的线程持有，则该方法会立马返回，调用该方法的线程持有该锁，并且lock hold count(锁持有数)设置成1。&lt;/li&gt;
      &lt;li&gt;如果该线程已经拥有该锁，则该方法立马返回，且lock hold count（锁持有数）增加1。&lt;/li&gt;
      &lt;li&gt;如果这个锁已经被其他线程持有，那么当前线程将不会被线程调度，同时当前线程会进入休眠状态直到以下两种情况之一发生：
        &lt;ul&gt;
          &lt;li&gt;当前线程获得锁&lt;/li&gt;
          &lt;li&gt;当前线程被Interrupt&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A06-reentrantlock/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A06-reentrantlock/</guid>
        
        
      </item>
    
      <item>
        <title>Java多线程学习5 Synchronized</title>
        <description>&lt;h1 id=&quot;java5-synchronized&quot;&gt;Java多线程学习5-synchronized&lt;/h1&gt;
&lt;p&gt;## 先来看看jsr133中lock的语义&lt;/p&gt;

&lt;p&gt;There are multiple mechanisms for communicating between threads. The most basic of these methods is synchronization, which is implemented using monitors. Each object is associated with a monitor, which a thread can lock or unlock. Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor.&lt;/p&gt;

&lt;p&gt;A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation.&lt;/p&gt;

&lt;p&gt;The synchronized statement computes a reference to an object; it then attempts to perform a lock action on that object’s monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.
A synchronized method automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method’s body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.&lt;/p&gt;

&lt;p&gt;The semantics neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that don’t deadlock, if necessary.&lt;/p&gt;

&lt;p&gt;Other mechanisms, such as reads and writes of volatile variables and classes provided in the java.util.concurrent package, provide alternative mechanisms for synchronization.&lt;/p&gt;

&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;
&lt;pre&gt;
package com.github.dunno.concurrent.sync;

import org.junit.Test;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Created by liang.he on 16/1/16.
 */
public class TestSync {
	//类锁：在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段
	//对象锁：在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段
	//私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）

	private Integer lock = new Integer(1);

	private Integer lock2 = new Integer(2);

	private final static Integer staticLock = new Integer(3);

	//无锁
	public void noLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;noLockMethod start! start:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;noLockMethod-lock:&quot; + lock2);
				System.out.println(&quot;noLockMethod-lock:&quot; + lock);
				System.out.println(&quot;noLockMethod-lock:&quot; + staticLock);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;noLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//对象锁1
	public synchronized void objectLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;objectLockMethod start! start:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;objectLockMethod-lock:&quot; + lock2);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;objectLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//对象锁2
	public void objectLockMethod2() {
		synchronized (this) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;objectLockMehtod2 start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;objectLockMehtod2-lock:&quot; + lock2);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;objectLockMehtod2 end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//私有锁 锁变量1
	public void privateLockMethod() {
		synchronized (lock) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;privateLockMethod1-lock:&quot; + lock2);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//私有锁 锁变量2
	public void privateLockMethod2() {
		synchronized (lock2) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod2 start! mills:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;privateLockMethod2-lock:&quot; + lock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//类锁
	public synchronized static void classLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;classLockMethod start! mills:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;classLockMethod-lock:&quot; + staticLock);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;classLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//类锁
	public static void classLockMethod2() {
		synchronized (TestSync.class) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;classLockMethod2 start! mills:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;classLockMethod2-lock:&quot; + staticLock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;classLockMethod2 end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	private ReentrantLock reentrantLock = new ReentrantLock();

	//独占锁
	public void reentrantLock() {
		try {
			reentrantLock.lock();
			long start = System.currentTimeMillis();
			System.out.println(&quot;reentrantLock start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;reentrantLock-lock:&quot; + lock2);
					System.out.println(&quot;reentrantLock-lock:&quot; + lock);
					System.out.println(&quot;reentrantLock-lock:&quot; + staticLock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;reentrantLock end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		} finally {
			reentrantLock.unlock();
		}
	}

	private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();


	public void readWriteLock() {

	}

	//测试私有锁锁不同变量是否会有竞争
	//结论:
	//只打开注释1,注释2,可以说明“当私有锁监视同一资源会竞争,等待其中一个资源释放,当监视的资源不是同一个不会产生竞争”
	//只打开注释3,注释4,可以说明“对象锁会互相竞争，等待另一个方法结束”
	//只打开注释5,注释6,可以说明&quot;类锁会互相竞争，等待另一个释放资源&quot;
	//只打开注释1,注释6,打开注释1,注释5,可以说明&quot;不同的锁不会竞争&quot;
	//只打开注释1,注释7,3-7或者5-7,可以说明&quot;无锁变量不会和锁变量竞争&quot;
	//不同类的锁不会竞争
	@Test
	public void test1() {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				Thread thread1 = new Thread(new Runnable() {
					@Override
					public void run() {

						//privateLockMethod();//注释1
						//objectLockMethod();//注释3
						//classLockMethod();//注释5
						reentrantLock();//注释8
					}
				});
				Thread thread2 = new Thread(new Runnable() {
					@Override
					public void run() {

						//privateLockMethod2();//注释2
						//objectLockMethod2();//注释4
						//classLockMethod2();//注释6
						//noLockMethod();//注释7
						reentrantLock();//注释9
					}
				});
				thread1.start();
				thread2.start();

				try {
					thread1.join();
					thread2.join();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

			}
		});
		thread.start();
		try {
			thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

&lt;/pre&gt;
</description>
        <pubDate>Sun, 24 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A05-synchronized/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A05-synchronized/</guid>
        
        
      </item>
    
      <item>
        <title>Java多线程学习4 线程的等待&amp;让步&amp;唤醒</title>
        <description>&lt;h1 id=&quot;java4-&quot;&gt;Java多线程学习4-线程的睡眠&amp;amp;等待&amp;amp;让步&amp;amp;唤醒&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;yield()
    &lt;ul&gt;
      &lt;li&gt;发送请求告诉调度器“当前线程”让出当前对处理器资源的占用。调度器可以忽略该请求。&lt;/li&gt;
      &lt;li&gt;很少场景会使用到这个方法，该方法可能对于debug或者出于测试的目的的场景有些用处（就是没有什么卵用的意思）。&lt;/li&gt;
      &lt;li&gt;D大调&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;sleep(long millis)
    &lt;ul&gt;
      &lt;li&gt;当前的执行线程（注意是当前执行线程，比如如果你万一使用t1.sleep(1000),也不建议这么写，不一定会对t1起作用）进入休眠(暂停执行)。&lt;/li&gt;
      &lt;li&gt;使用该方法时并不会让出对象的监视器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wait(long timeout)
    &lt;ul&gt;
      &lt;li&gt;使“当前线程”等待直到其他线程调用了notify()或者notifyAll()方法。&lt;/li&gt;
      &lt;li&gt;“当前线程”必须是此时正在起作用的对象监视器的所有者。&lt;/li&gt;
      &lt;li&gt;该方法让“当前线程（以下用T表示）”等待同时释放对象监视器的锁，而且T在等待期间也不会再进行线程调度。除非发生以下一种情况：
        &lt;ul&gt;
          &lt;li&gt;其他线程调用notify()时,随机唤醒了T线程。&lt;/li&gt;
          &lt;li&gt;其他线程调用了notifyAll()&lt;/li&gt;
          &lt;li&gt;其他线程interrupts了T线程&lt;/li&gt;
          &lt;li&gt;指定的真实等待时间结束。当蚕食timeout是0时，那么则不会考虑timeout，线程T会一直等待直到被唤醒。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;线程可能不在上面四种情况下被唤醒，我们称为“spurious wakeup”,在实际操作中几乎不会发生。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wait()
    &lt;ul&gt;
      &lt;li&gt;wait()的实现是wait(0);&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;notify()
    &lt;ul&gt;
      &lt;li&gt;唤醒一个在该对象监视器上等待的单个线程。&lt;/li&gt;
      &lt;li&gt;唤醒的机制是随机唤醒。&lt;/li&gt;
      &lt;li&gt;一次wait方法只能使一个线程在该对象监视器等待。&lt;/li&gt;
      &lt;li&gt;被唤醒的线程不会开始处理程序直到当前线程释放了对这个对象监视器的锁。&lt;/li&gt;
      &lt;li&gt;这个方法应该被这个对象监视器的拥有者的这个线程调用。一个线程成为对象监视器的拥有者有以下三个方法：
        &lt;ul&gt;
          &lt;li&gt;通过执行一个这个对象的同步实例方法&lt;/li&gt;
          &lt;li&gt;通过执行锁住这个对象的同步块方法&lt;/li&gt;
          &lt;li&gt;对于Class类型的对象来说，通过执行这个类的一个静态的同步方法。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;一个线程在一个时刻只能拥有一个对象监视器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;notifyAll()
    &lt;ul&gt;
      &lt;li&gt;唤醒在此对象监视器上面的所有等待的线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A04-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85&%E8%AE%A9%E6%AD%A5&%E5%94%A4%E9%86%92/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A04-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85&%E8%AE%A9%E6%AD%A5&%E5%94%A4%E9%86%92/</guid>
        
        
      </item>
    
      <item>
        <title>Java多线程学习3 守护线程</title>
        <description>&lt;h1 id=&quot;java3-&quot;&gt;Java多线程学习3-守护线程的创建和执行&lt;/h1&gt;
&lt;p&gt;## 介绍
java有一种线程叫守护线程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这种线程拥有非常低的执行权值且一般在其他线程在同一程序不执行时执行。&lt;/li&gt;
  &lt;li&gt;通过调用setDaemon(true);将该线程设置成守护线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Demo
验证一下1&lt;/p&gt;
&lt;pre&gt;
public class TestDaemonThread {

	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				int sleep = 2;

				while ( sleep &amp;gt; 0) {
					try {
						Thread.sleep(1000);
						System.out.println(Thread.currentThread().getName() + &quot;i have sleep 1 secends!&quot;);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sleep --;
				}

				System.out.println(Thread.currentThread().getName() + &quot;i &#39;m wake up&quot;);
			}
		});
		thread.setName(&quot;not daemon thread &quot;);

		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				int sleep = 5;

				while ( sleep &amp;gt; 0) {
					try {
						Thread.sleep(1000);
						System.out.println(Thread.currentThread().getName() + &quot;i have sleep 1 secends!&quot;);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sleep --;
				}

				System.out.println(Thread.currentThread().getName() + &quot;i &#39;m wake up&quot;);
			}
		});
		thread2.setName(&quot;daemon thread &quot;);
		thread2.setDaemon(true);

		thread.start();
		thread2.start();

		try {
			thread2.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(thread.getName() + &quot;pro &quot; + thread.getPriority());
		System.out.println(thread2.getName() + &quot;pro &quot; + thread2.getPriority());

	}
}
&lt;/pre&gt;
&lt;p&gt;上面代码中，我们执行两个线程，一个普通线程，sleep2秒，另一个线程是守护线程，sleep5秒，根据上面的例子，我们预测一下，普通线程执行2秒后，主线程就退出了。&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A03-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A03-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</guid>
        
        
      </item>
    
      <item>
        <title>Java多线程学习2 打断线程</title>
        <description>&lt;h1 id=&quot;java2-&quot;&gt;Java多线程学习2-打断线程&amp;amp;等待线程的终止&lt;/h1&gt;
&lt;p&gt;##打断线程demo&lt;/p&gt;
&lt;pre&gt;
/**
 * Created by liang.he on 16/1/12.
 * 测试打断一个线程
 */
public class TestInterruptThread extends Thread{

	private boolean flag = true;

	@Override
	public void run() {
		while (true) {
			System.out.println(&quot;i&#39;m still running!&quot;);
			if (isInterrupted()) {
				System.out.println(&quot;The Prime Generator has been Interrupted&quot;);
				return;
			}
		}
	}

	public static void main(String[] args ) {
		TestInterruptThread task = new TestInterruptThread();
		task.start();
		try {
			Thread.sleep(5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		task.interrupt();
	}
}
&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;等待线程的终止&lt;/h2&gt;

&lt;p&gt;调用线程的join()方法。&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A02-%E6%89%93%E6%96%AD%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A02-%E6%89%93%E6%96%AD%E7%BA%BF%E7%A8%8B/</guid>
        
        
      </item>
    
      <item>
        <title>Java多线程学习1 创建线程</title>
        <description>&lt;h1 id=&quot;java1-&quot;&gt;Java多线程学习1-创建线程&lt;/h1&gt;
&lt;p&gt;[toc]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;创建一个线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;实现Runnable接口
    &lt;pre&gt;
  public TestRunnable implements implements Runnable {
      @Override
      public void run() {
      }
  }
  new Thread(new TestRunnable()).start();
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;继承Thread类
    &lt;pre&gt;
  public class TestThread extends Thread {
      @Override
      public void run() {
      }
  }
  new TestThread().start();
  &lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;启动一个线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;启动一个线程
    &lt;pre&gt;
  new Thread().start();
  &lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;线程的状态&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;NEW 当线程创建之后但是还没有调用start方法时会是这个状态。&lt;/li&gt;
  &lt;li&gt;RUNNABLE 当线程正在JVM中执行时（但实际也有可能正在等待操作系统的其他资源，比如处理器资源），线程会被标记成该状态&lt;/li&gt;
  &lt;li&gt;BOLCKED 线程正在等待一个监视器锁或者进入同步块/方法，或者在调用Object.wait()方法之后重进入同步块/方法&lt;/li&gt;
  &lt;li&gt;WAITING 线程正在等待另一个线程执行完一个特定的动作时会标记成该状态，比如：一个线程被调用了Object.wait()会使它处于WAITING状态直到另一个线程调用了Object.notify()或者Object.notifyAll()唤醒该线程；或者该线程被调用了Object.join()等待另一个线程的终止时会处于WAITING状态。&lt;/li&gt;
  &lt;li&gt;TIMED_WAITING 在特定的时间内等待另一个线程。以下方法会产生该作用：
    &lt;ul&gt;
      &lt;li&gt;Thread.sleep&lt;/li&gt;
      &lt;li&gt;Object.wait with timeout&lt;/li&gt;
      &lt;li&gt;Thread.join with timeout&lt;/li&gt;
      &lt;li&gt;LockSupport.parkNanos&lt;/li&gt;
      &lt;li&gt;LockSupport.parkUntil&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TERMINATED 线程的终止状态，当线程完成它的执行时标记成该状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;startrun&quot;&gt;start和run的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;start的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
/**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
     * &lt;p&gt;
     * The result is that two threads are running concurrently: the
     * current thread (which returns from the call to the
     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
     * &lt;code&gt;run&lt;/code&gt; method).
     * &lt;p&gt;
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * @exception  IllegalThreadStateException  if the thread was already
     *               started.
     * @see        #run()
     * @see        #stop()
     */
    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

* run的实现
&lt;pre&gt;
	/**
     * If this thread was constructed using a separate
     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that
     * &lt;code&gt;Runnable&lt;/code&gt; object&#39;s &lt;code&gt;run&lt;/code&gt; method is called;
     * otherwise, this method does nothing and returns.
     * &lt;p&gt;
     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.
     *
     * @see     #start()
     * @see     #stop()
     * @see     #Thread(ThreadGroup, Runnable, String)
     */
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

* 方法的区别
	* start方法是一个线程开始执行的原因（所以我们应该通过调用start方法来启动一个线程，而不是run）
	* start方法至多启动同一个线程一次。
	* 线程再完成执行后，不会重新启动start方法。
	* start方法不会被“主线程”或者是虚拟机创建/设置的“系统态”线程调用（而是创建一个新线程来调用）。
	* run就是一个普通的方法，可以被重复调用。
&lt;/p&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/p&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 16 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io//2016/01/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io//2016/01/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</guid>
        
        
      </item>
    
  </channel>
</rss>
