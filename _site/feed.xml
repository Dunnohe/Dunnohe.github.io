<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io/</link>
    <atom:link href="http://dunnohe.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 01 Aug 2016 17:16:29 +0800</pubDate>
    <lastBuildDate>Mon, 01 Aug 2016 17:16:29 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>JDK-命令行工具介绍2</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstack&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
https://dzone.com/articles/how-analyze-java-thread-dumps
https://gist.github.com/rednaxelafx/843622&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstacka&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack 根据指定的端口或者远程debug服务打印出线程栈跟踪信息。&lt;/p&gt;

&lt;h2 id=&quot;jstack--l-7124-pid7124&quot;&gt;jstack -l 7124 打出pid为7124的线程栈跟踪信息&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
部分输出
2016-07-31 22:24:21
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.76-b04 mixed mode):

&quot;Thread-11-EventThread&quot; daemon prio=5 tid=0x00007f8e9d8e0000 nid=0x32327 waiting on condition [0x0000700013bca000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  &amp;lt;0x00000007eef76740&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:494)

   Locked ownable synchronizers:
	- None

&quot;Thread-11-SendThread(10.4.241.128:2181)&quot; daemon prio=5 tid=0x00007f8e9d857000 nid=0x2a33f runnable [0x0000700013ac7000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:200)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
	- locked &amp;lt;0x00000007eef75488&amp;gt; (a sun.nio.ch.Util$2)
	- locked &amp;lt;0x00000007eef75478&amp;gt; (a java.util.Collections$UnmodifiableSet)
	- locked &amp;lt;0x00000007eef75358&amp;gt; (a sun.nio.ch.KQueueSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
	at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:349)
	at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1081)

   Locked ownable synchronizers:
	- None
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjstack--l-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;“Thread-11-EventThread”&lt;/strong&gt; 线程名字，当使用Thread类生成的线程，thread会被命名成Thread-(Number)，而使用ThreadFactory类生成的线程会被命名成pool-(number)-thread-(number)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt; 如果有这一列代表是守护线程，没有则说明不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prio=5&lt;/strong&gt; 代表该线程的权值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tid=0x00007f8e9d857000&lt;/strong&gt; 代表该线程唯一的id（线程id），这个id是java层面的id&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nid=0x2a33f&lt;/strong&gt; 本地线程id(Native thread ID)，这个id的值依赖于系统平台层面。
    &lt;ul&gt;
      &lt;li&gt;windows下，就是操作系统级别的线程id&lt;/li&gt;
      &lt;li&gt;Linux下，nid是线程的pid （这里多提一句，我们大多场景是在linux上，当出现问题时，我们先可以利用 top -Hp 找出不正常的线程pid，把pid转成16进制（因为nid是16进制），然后根据这个转好的pid立马找到线程在干嘛，通常就能发现问题，top的用法，可以回滚之前的top使用的总结。 ）&lt;/li&gt;
      &lt;li&gt;Solaris下，nid是thr_self()的返回值&lt;/li&gt;
      &lt;li&gt;在Mac OS下，可以认为是本地pthread_t的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;waiting on condition [0x0000700013bca000] / runnable [0x0000700013ac7000]&lt;/strong&gt; 线程此时的状态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最后一栏&lt;/strong&gt; 代表线程调用的完整的堆栈信息&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/01/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/01/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这里我们先介绍用法比较简单的几个命令:jps,jmap,jhat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjpsa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jps JVM进程状态工具

→ jps 列出进程id和main函数名称
7124 AppMain
10829 Jps

→ jps -q 只输出进程id
7124
10807

→ jps -m 输出进程id和主函数参数
7124 AppMain org.codehaus.classworlds.Launcher -Didea.version=15.0 clean jetty:run -Pperformance
10857 Jps -m

→ jps -l 只输出进程id和主函数路径
7124 com.intellij.rt.execution.application.AppMain
10888 sun.tools.jps.Jps

→ jps -v 输出进程id和给传递给jvm的参数（最常用）
7124 AppMain -Xms2048m -Xmx2048m -XX:PermSize=1024m -XX:MaxPermSize=1024m -Dmaven.home=/usr/local/apache-maven-3.1.1 -Dclassworlds.conf=/usr/local/apache-maven-3.1.1/bin/m2.conf -Didea.launcher.port=7533 -Didea.launcher.bin.path=/Applications/IntelliJ IDEA 15.app/Contents/bin -Dfile.encoding=UTF-8
10933 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home -Xms8m
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namejhatjhata&quot;&gt;&lt;a name=&quot;jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jhat 堆dump游览器 - 启动一个web服务在一个堆dump文件上（比如使用jmap -dump产生的&lt;br /&gt;文件），可以在界面来浏览堆数据。

jhat -h 帮助

jhat filename 分析dump文件
在上面我们使用了jmap -dump:live,format=b,file=test 7124
现在我们来浏览一下数据

→ jhat test
Reading from test...
Dump file created Sun Jul 31 18:20:41 CST 2016
Snapshot read, resolving...
Resolving 4317462 objects...
WARNING:  Failed to resolve object id 0x788fe2078 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f382a8 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f37f40 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f19328 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f191b0 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f18f90 for field clazz (signature L)
Chasing references, expect 863 dots..................................
Eliminating duplicate references..................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.

输出到这里说明已经ok了，那么接下来我们可以打开游览器，输入127.0.0.1:7000就可以浏览这些数据了
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jhat/jhat.png&quot; alt=&quot;jhat_输出&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;a-nametcyjmapa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jmap java内存图 根据指定的进程id或者核心文件或者远程debug server输出对象或者堆内存的情况

jmap 或者 jmap -help 输出使用帮助 

jmap -histo:7124 打印堆对象柱状图
下面是部分输出：num:编号 instance:实例数量 byte:大小 class-类名

 num     #instances         #bytes  class name
----------------------------------------------
   1:       2251207      406535312  [C
   2:        328187      263542800  [B
   3:         90692       51871032  [I
   4:       1922400       46137600  java.lang.String
   5:       1121773       35896736  java.util.HashMap$Entry
   6:        237870       32585432  &lt;constmethodklass&gt;
   7:        783437       31337480  java.util.HashMap$KeyIterator
   8:        237870       30457760  &lt;methodklass&gt;
   9:         21767       25312768  &lt;constantpoolklass&gt;
   
jmap -dump:&lt;dump-option&gt;

dump-option:
live  指定了该选择则只dump live object，所有就dump堆中所有对象。
format=b 二进制格式
file=&lt;file&gt; 指定dump的具体文件
比如:
jmap -dump:live,format=b,file=test 7124


&lt;/file&gt;&lt;/dump-option&gt;&lt;/constantpoolklass&gt;&lt;/methodklass&gt;&lt;/constmethodklass&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Java-mybatis generator返回主键的用法</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;用法介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;附：mybatis主键的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;用法介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;使用mybatis plugin,配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;install&amp;lt;/phase&amp;gt;
            &amp;lt;id&amp;gt;Generate MyBatis Artifacts&amp;lt;/id&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;configurationFile&amp;gt;src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
        &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;查看官方对于生成主键的配置的解释&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.mybatis.org/generator/configreference/generatedKey.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;generatorConfig.xml 配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nameckzlgeneratorconfiga&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code class=&quot;XML&quot;&gt;
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot; &amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;classPathEntry location=&amp;quot;/Users/lianghe/.m2/repository/mysql/mysql-connector-java/5.1.36/mysql-connector-java-5.1.36.jar&amp;quot;/&amp;gt;

    &amp;lt;context id=&amp;quot;mysql&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.EqualsHashCodePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.SerializablePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.ToStringPlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.RowBoundsPlugin&amp;quot;/&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot;/&amp;gt;

        &amp;lt;!-- &amp;#27880;&amp;#37322; --&amp;gt;
        &amp;lt;commentGenerator &amp;gt;
            &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#21462;&amp;#28040;&amp;#27880;&amp;#37322; --&amp;gt;
            &amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt; &amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#29983;&amp;#25104;&amp;#27880;&amp;#37322;&amp;#20195;&amp;#26102;&amp;#38388;&amp;#25139;--&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;

        &amp;lt;!-- jdbc --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
                        connectionURL=&amp;quot;jdbc:mysql://xx.xx.xx.xx/hotel_pda&amp;quot;
                        userId=&amp;quot;xxx&amp;quot;
                        password=&amp;quot;xxx&amp;quot; /&amp;gt;
        &amp;lt;!-- &amp;#29983;&amp;#25104;model --&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.xxx.domain&amp;quot;
                            targetProject=&amp;quot;src/main/java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;mapper/auto&amp;quot;
                         targetProject=&amp;quot;src/main/resources&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql client--&amp;gt;
        &amp;lt;javaClientGenerator targetPackage=&amp;quot;com.xxx.dao.auto&amp;quot;
                             targetProject=&amp;quot;src/main/java&amp;quot;
                             type=&amp;quot;XMLMAPPER&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;

        &amp;lt;!-- Tables --&amp;gt;
        &amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namexkdmybatisa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;附：mybatis返回主键的用法&lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;
&lt;code class=&quot;Java&quot;&gt;
public int insert(Domain domain) {
	//插入完成后 domain的主键id字段会被赋值，直接返回即可
	domainMapper.insertSelective(domain);
	return domain.getId();
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 04:09:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-lsof命令</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;lsof常用的一些命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;lsof（“list open files”）命令名称很容易记住，把它看成“ls + of”, 在linux下面，一切都是文件，lsof则可以查看这些文件。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://www.tecmint.com/10-lsof-command-examples-in-linux/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html?highlight=lsof&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkda&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;先了解输出吧&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们先运行一下lsof -R(加-R 可以打出ppid)命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -R
COMMAND     PID  PPID      USER   FD      TYPE             DEVICE SIZE/OFF      NODE NAME
init          1     0      root  cwd   unknown                                       /proc/1/cwd (readlink: Permission denied)
init          1     0      root  rtd   unknown                                       /proc/1/root (readlink: Permission denied)
init          1     0      root  txt   unknown                                       /proc/1/exe (readlink: Permission denied)
init          1     0      root NOFD                                                 /proc/1/fd (opendir: Permission denied)
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;COMMAND 进程名称&lt;/li&gt;
  &lt;li&gt;PID 进程id&lt;/li&gt;
  &lt;li&gt;PPID 进程父id&lt;/li&gt;
  &lt;li&gt;USER 进程所有者&lt;/li&gt;
  &lt;li&gt;FD 文件描述符
    &lt;pre&gt;
  &lt;code&gt;
  （1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
  （2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
  （3）lnn：library references (AIX);
  （4）er：FD information error (see NAME column);
  （5）jld：jail directory (FreeBSD);
  （6）ltx：shared library text (code and data);
  （7）mxx ：hex memory-mapped type number xx.
  （8）m86：DOS Merge mapped file;
  （9）mem：memory-mapped file;
  （10）mmap：memory-mapped device;
  （11）pd：parent directory;
  （12）rtd：root directory;
  （13）tr：kernel trace file (OpenBSD);
  （14）v86  VP/ix mapped file;
  （15）0：表示标准输出
  （16）1：表示标准输入
  （17）2：表示标准错误
  一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等
  （1）u：表示该文件被打开并处于读取/写入模式
  （2）r：表示该文件被打开并处于只读模式
  （3）w：表示该文件被打开并处于
  （4）空格：表示该文件的状态模式为unknow，且没有锁定
  （5）-：表示该文件的状态模式为unknow，且被锁定
  同时在文件状态模式后面，还跟着相关的锁
  （1）N：for a Solaris NFS lock of unknown type;
  （2）r：for read lock on part of the file;
  （3）R：for a read lock on the entire file;
  （4）w：for a write lock on part of the file;（文件的部分写锁）
  （5）W：for a write lock on the entire file;（整个文件的写锁）
  （6）u：for a read and write lock of any length;
  （7）U：for a lock of unknown type;
  （8）x：for an SCO OpenServer Xenix lock on part      of the file;
  （9）X：for an SCO OpenServer Xenix lock on the      entire file;
  （10）space：if there is no lock.
  &lt;/code&gt;
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;TYPE 文件类型
    &lt;pre&gt;
  &lt;code&gt;
  （1）DIR：表示目录
  （2）CHR：表示字符类型
  （3）BLK：块设备类型
  （4）UNIX： UNIX 域套接字
  （5）FIFO：先进先出 (FIFO) 队列
  （6）IPv4：网际协议 (IP) 套接字
  &lt;/code&gt;
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;DEVICE 指定磁盘的名称&lt;/li&gt;
  &lt;li&gt;SIZE 文件大小&lt;/li&gt;
  &lt;li&gt;NODE 索引节点&lt;/li&gt;
  &lt;li&gt;NAME 打开文件的确切名称&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcylsofa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;lsof常用的一些命令&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定用户打开的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
lsof -u heliang05
COMMAND  PID      USER   FD      TYPE             DEVICE SIZE/OFF      NODE NAME
sshd    3126 heliang05  cwd   unknown                                       /proc/3126/cwd (readlink: Permission denied)
sshd    3126 heliang05  rtd   unknown                                       /proc/3126/root (readlink: Permission denied)
sshd    3126 heliang05  txt   unknown                                       /proc/3126/exe (readlink: Permission denied)
sshd    3126 heliang05 NOFD                                                 /proc/3126/fd (opendir: Permission denied)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;找到在特定TCP端口上运行的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i TCP:22
COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    1471    root    3u  IPv4  12683      0t0  TCP *:ssh (LISTEN)
sshd    1471    root    4u  IPv6  12685      0t0  TCP *:ssh (LISTEN)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;找到特定TCP端口范围上的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i TCP:0-1024
COMMAND    PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
Google     258 lianghe  153u  IPv4 0x8bc54911385f362b      0t0  TCP 172.30.30.61:57712-&amp;gt;10.32.255.116:http (ESTABLISHED)
Google     258 lianghe  156u  IPv4 0x8bc5491133dc4d23      0t0  TCP 172.30.30.61:57819-&amp;gt;103.37.152.63:https (CLOSE_WAIT)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的网络连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    6u  IPv4  11326      0t0  UDP *:sunrpc
rpcbind   1203     rpc    7u  IPv4  11330      0t0  UDP *:954
rpcbind   1203     rpc   11u  IPv6  11336      0t0  TCP *:sunrpc (LISTEN)
avahi-dae 1241   avahi   13u  IPv4  11579      0t0  UDP *:mdns
avahi-dae 1241   avahi   14u  IPv4  11580      0t0  UDP *:58600
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的ipv4连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i 4
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    6u  IPv4  11326      0t0  UDP *:sunrpc
rpcbind   1203     rpc    7u  IPv4  11330      0t0  UDP *:954
rpcbind   1203     rpc    8u  IPv4  11331      0t0  TCP *:sunrpc (LISTEN)
avahi-dae 1241   avahi   13u  IPv4  11579      0t0  UDP *:mdns
avahi-dae 1241   avahi   14u  IPv4  11580      0t0  UDP *:58600
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的ipv6连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i 6
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    9u  IPv6  11333      0t0  UDP *:sunrpc
rpcbind   1203     rpc   10u  IPv6  11335      0t0  UDP *:954
rpcbind   1203     rpc   11u  IPv6  11336      0t0  TCP *:sunrpc (LISTEN)
rpc.statd 1277 rpcuser   10u  IPv6  11858      0t0  UDP *:55800
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;根据指定的pid查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -p 1
COMMAND PID USER   FD   TYPE     DEVICE SIZE/OFF   NODE NAME
init      1 root  cwd    DIR      253,0     4096      2 /
init      1 root  rtd    DIR      253,0     4096      2 /
init      1 root  txt    REG      253,0   145180 147164 /sbin/init
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;列出谁在使用某个端口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i :3306
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这些参数也可以互相组合使用&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jul 2016 04:20:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/21/Linux-lsof%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/21/Linux-lsof%E5%91%BD%E4%BB%A4/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-top命令</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;top常用的一些命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;top命令是Linux下常用的性能分析工具,特别是应用性能报警的时候，我们经常会用到这个命令&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://linuxaria.com/howto/understanding-the-top-command-on-linux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html?highlight=top&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdtopa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们先运行一下top命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
top - 13:26:40 up 188 days, 20:28,  1 user,  load average: 0.07, 0.05, 0.05
Tasks: 145 total,   1 running, 144 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.7%us,  0.3%sy,  0.0%ni, 99.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   8059416k total,  7374232k used,   685184k free,   288420k buffers
Swap:  2096440k total,        0k used,  2096440k free,  5570192k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND     
 8182 sankuai   20   0  981m  40m 3420 S  3.0  0.5 180:24.71 sg_agent 
17939 sankuai   20   0 3612m 996m  17m S  1.7 12.7 639:16.22 java 
 8193 sankuai   20   0 1045m  29m 3152 S  1.3  0.4  84:28.97 sg_agent_worker   
10107 sankuai   20   0  268m 6724 3616 S  0.3  0.1   7:05.65 log_agent_file    
    1 root      20   0 23500 1552 1212 S  0.0  0.0   0:05.93 init 
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd 
    3 root      RT   0     0    0    0 S  0.0  0.0   0:54.01 migration/0       
    4 root      20   0     0    0    0 S  0.0  0.0   3:28.67 ksoftirqd/0       
    5 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;第一行内容-top
    &lt;ul&gt;
      &lt;li&gt;13:26:40 &lt;strong&gt;系统当前时间&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;188 days, 20:28, &lt;strong&gt;系统开机到现在经过了多少时间&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;1 user, &lt;strong&gt;当前1个用户在线&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;load average: 0.07, 0.05, 0.05 &lt;strong&gt;系统1分钟、5分钟、15分钟的CPU负载信息&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二行内容-task
    &lt;ul&gt;
      &lt;li&gt;Tasks &lt;strong&gt;任务,右边的数字也就是一个对任务的统计信息&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;145 total, &lt;strong&gt;任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;1 running, &lt;strong&gt;运行的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;144 sleeping, &lt;strong&gt;休眠的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;0 stopped, &lt;strong&gt;停止的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;0 zombie, &lt;strong&gt;等待父进程来停止的任务总数&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第三行内容-cpu
    &lt;ul&gt;
      &lt;li&gt;0.7%us (&lt;em&gt;user processes&lt;/em&gt;)用户进程的CPU百分比,不包含renice值为负的任务。&lt;/li&gt;
      &lt;li&gt;0.3%sy (&lt;em&gt;system processes&lt;/em&gt;)系统进程的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%ni (processes with priority &lt;em&gt;upgrade nice&lt;/em&gt;)改变过优先级的进程的CPU百分比。&lt;/li&gt;
      &lt;li&gt;99.0%id 没被利用的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%wa (processes &lt;em&gt;waiting&lt;/em&gt; for I/O operations)等待I/O的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%hi (&lt;em&gt;hardware interrupts&lt;/em&gt;)硬中断的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%si (&lt;em&gt;software interrupts&lt;/em&gt;)软终端的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%st (&lt;em&gt;Steal Time&lt;/em&gt;)通常我们服务器是一个虚拟机，这个指标就代表宿主机上其他虚拟机实例偷取的CPU时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第四行内容-内存利用
    &lt;ul&gt;
      &lt;li&gt;8059416k total, 物理内存总量&lt;/li&gt;
      &lt;li&gt;7374232k used, 使用的物理内存量&lt;/li&gt;
      &lt;li&gt;685184k free, 空闲的物理内存量&lt;/li&gt;
      &lt;li&gt;288420k buffers, 用作内核缓存的物理内存量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第五行内容-交换空间
    &lt;ul&gt;
      &lt;li&gt;2096440k total, 交换区总量&lt;/li&gt;
      &lt;li&gt;0k used, 使用的交换区量&lt;/li&gt;
      &lt;li&gt;2096440k free, 空闲的交换区量&lt;/li&gt;
      &lt;li&gt;5570192k cached, 缓冲交换区总量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;大于第六行内容-进程列表
    &lt;ul&gt;
      &lt;li&gt;PID：进程的ID&lt;/li&gt;
      &lt;li&gt;USER：进程所有者&lt;/li&gt;
      &lt;li&gt;PR：进程的优先级别，越小越优先被执行&lt;/li&gt;
      &lt;li&gt;NI：The “NICE” value of the process，&lt;a href=&quot;#niv&quot;&gt;关于nice value of process的解释&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;VIRT：进程占用的虚拟内存&lt;/li&gt;
      &lt;li&gt;RES：进程占用的物理内存&lt;/li&gt;
      &lt;li&gt;SHR：进程使用的共享内存&lt;/li&gt;
      &lt;li&gt;S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数&lt;/li&gt;
      &lt;li&gt;%CPU：进程占用CPU的使用率&lt;/li&gt;
      &lt;li&gt;%MEM：进程使用的物理内存和总内存的百分比&lt;/li&gt;
      &lt;li&gt;TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。&lt;/li&gt;
      &lt;li&gt;COMMAND：进程启动命令名称&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcytopa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;top常用的一些命令&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;命令行命令
    &lt;ul&gt;
      &lt;li&gt;a 根据内存利用率排序&lt;/li&gt;
      &lt;li&gt;b 在“批量模式”启动top,这种模式很利于把输出top的结果，这种模式下，top不再接受你输入的&lt;strong&gt;界面命令&lt;/strong&gt;，同时它会运行至 -n 命令设置的时间或者手动kill掉&lt;/li&gt;
      &lt;li&gt;H 线程开关（这个经常用于排查故障，找出有问题的线程pid），使用这个命令会把进程私有的线程也都输出出来。&lt;/li&gt;
      &lt;li&gt;n 用法 -n (number)，top每隔一段时间就会输出一次，这个-n就是指定top输出的次数&lt;/li&gt;
      &lt;li&gt;p 指定pid输出对应的进程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;界面命令 （输入top之后可以输入的命令）
    &lt;ul&gt;
      &lt;li&gt;q 退出&lt;/li&gt;
      &lt;li&gt;space 立即刷新&lt;/li&gt;
      &lt;li&gt;s 设置刷新时间&lt;/li&gt;
      &lt;li&gt;c COMMAND 显示完整的命令 等效于 top -c&lt;/li&gt;
      &lt;li&gt;k kill 进程&lt;/li&gt;
      &lt;li&gt;u 指定用户&lt;/li&gt;
      &lt;li&gt;t 显示或隐藏进程和CPU状态信息&lt;/li&gt;
      &lt;li&gt;m 显示或隐藏内存状态信息&lt;/li&gt;
      &lt;li&gt;l 显示或隐藏uptime信息&lt;/li&gt;
      &lt;li&gt;1 监控每个逻辑CPU的状况&lt;/li&gt;
      &lt;li&gt;P 按%CPU使用率排行&lt;/li&gt;
      &lt;li&gt;T 按MITE+排行&lt;/li&gt;
      &lt;li&gt;M 按%MEM排行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他命令请使用 man top&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namenivnice-value-of-processa&quot;&gt;&lt;a name=&quot;niv&quot;&gt;nice value of process&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;http://askubuntu.com/questions/399357/what-does-the-nice-value-mean-in-cpu-utilization-statistics&lt;/p&gt;

&lt;p&gt;The nice value for the processor is&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the time the CPU has spent running users’ processes that have been “niced”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(from man top) A “niced” process is one with a positive nice value. So if the processor’s nice value is high, that means it is working with some low priority processes. So this indicator is useful when you see high CPU utilization and you are afraid that this high load will have bad effect on your system:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;High CPU utilization with high nice value: Nothing to worry, not so important tasks doing their job, important processes will easily get CPU time if they need. This situation is not a real bottleneck.&lt;/li&gt;
  &lt;li&gt;High CPU utilization with low nice value: Something to worry because the CPU is stressed with important processes so these or new processes will have to wait. This situation is a real bottleneck.
I think this nice value is not too important for a simple user, this is more useful in a server environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：nice value值越高的时候，被cpu执行的机会越少，如果进程占用cpu比较高，同时nice value也比较高的话，你就需要担心了。说明此时cpu比较紧张&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Jun 2016 21:18:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/06/20/Linux-Top%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/06/20/Linux-Top%E5%91%BD%E4%BB%A4/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aml&quot;&gt;awk命令&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#qb&quot;&gt;起步&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nzbl&quot;&gt;内置变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#zfcpp&quot;&gt;字符串的匹配&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cfwj&quot;&gt;拆分文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tj&quot;&gt;统计&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dybg&quot;&gt;打印表格&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hjbl&quot;&gt;环境变量&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。&lt;/p&gt;

&lt;p&gt;之前了解了常用的几个统计读取日志的命令以及正则表达式,这节了解一下非常强大的两个命令,一个是sed,一个是awk,这两个命令能够完成绝大部分的关键词的取用和统计。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://coolshell.cn/articles/9070.html#more-9070&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大量的例子都是从这里搬运的，推荐大家看酷壳，个人觉得帮助到我很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-nameamlawka&quot;&gt;&lt;a name=&quot;aml&quot;&gt;awk命令&lt;/a&gt;&lt;/h1&gt;

&lt;h3 id=&quot;a-nameqba&quot;&gt;&lt;a name=&quot;qb&quot;&gt;起步&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;功能：管道流编辑器,它可以读指定的文件或者标准输入流,通过一系列的命名可以去修改读到的输入,然后再将修改后的输入进行输出。它可以对匹配的每行都进行处理，比如同时加上什么东西，替换什么东西，减少什么东西。&lt;br /&gt;
直接看例子：&lt;br /&gt;
测试文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ cat test
1-2-3-4-5
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取出部分字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;{print $1 &quot; lalala &quot; $4}&#39; test 
1 lalala 4
2 lalala 4
3 lalala 4
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面加上判断条件&lt;br /&gt;
&lt;strong&gt;其中的“==”为比较运算符。其他比较运算符：!=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1==2 || $1==3 {print $1 &quot; lalala &quot; $4}&#39; test 
2 lalala 4
3 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来一个吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 {print $1 &quot; lalala &quot; $4}&#39; test 
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namenzbla&quot;&gt;&lt;a name=&quot;nzbl&quot;&gt;内置变量&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们可以来了解一下awk的一些内建变量,然后直接来使用看看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$0	当前记录（这个变量中存放着整个行的内容）
$1~$n	当前记录的第n个字段，字段间由FS分隔
FS	输入字段分隔符 默认是空格或Tab
NF	当前记录中的字段个数，就是有多少列
NR	已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。
FNR	当前记录数，与NR不同的是，这个值会是各个文件自己的行号
RS	输入的记录分隔符， 默认为换行符
OFS	输出字段分隔符， 默认也是空格
ORS	输出的记录分隔符，默认为换行符
FILENAME	当前输入文件的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试NR，把第一行打出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 || NR==1 {print $1 &quot; lalala &quot; $4}&#39; test
1 lalala 4
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;BEGIN{FS=&quot;:&quot;} {print $1 &quot; lalala &quot; $4}&#39; test
等价于
→ awk -F &quot;-&quot; &#39;{print $1 &quot; lalala &quot; $4}&#39; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你要指定多个分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &#39;[;:]&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OFS的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 || NR==1 {print $1,$2,$3}&#39; OFS=&quot;输出记录分隔符&quot; test 
1输出记录分隔符2输出记录分隔符3
4输出记录分隔符2输出记录分隔符3
5输出记录分隔符2输出记录分隔符3
6输出记录分隔符2输出记录分隔符3
7输出记录分隔符2输出记录分隔符3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namezfcppa&quot;&gt;&lt;a name=&quot;zfcpp&quot;&gt;字符串匹配&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;匹配第一列有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1 ~ /1/ &#39; test 
1-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配第一列没有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1 !~ /1/ &#39; test 
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配这一行有1的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;/1/&#39; test  
1-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配这一行没有1的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;!/1/&#39; test 
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namecfwja&quot;&gt;&lt;a name=&quot;cfwj&quot;&gt;拆分文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;匹配第一列有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F&quot;-&quot; &#39;{print &amp;gt; $1}&#39; test

→ ll
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 1
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 2
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 3
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 4
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 5
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 6
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 7

→ cat 1
1-2-3-4-5

→ cat 2
2-2-3-4-5

→ cat 3
3-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以把指定的列输出到文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F&quot;-&quot; &#39;{print $1,$2 &amp;gt; $1}&#39; test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-nametja&quot;&gt;&lt;a name=&quot;tj&quot;&gt;统计&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ ls -l  *.cpp *.c *.h | awk &#39;{sum+=$5} END {print sum}&#39;
2511401
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namedybga&quot;&gt;&lt;a name=&quot;dybg&quot;&gt;打印表格&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：&lt;/p&gt;

&lt;p&gt;BEGIN{ 这里面放的是执行前的语句 }
END {这里面放的是处理完所有的行后要执行的语句 }
{这里面放的是处理每一行时要执行的语句}
为了说清楚这个事，我们来看看下面的示例：&lt;/p&gt;

&lt;p&gt;假设有这么一个文件（学生成绩表）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0
 
    printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;
    printf &quot;---------------------------------------------\n&quot;
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf &quot;---------------------------------------------\n&quot;
    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer
    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namehjbla&quot;&gt;&lt;a name=&quot;hjbl&quot;&gt;环境变量&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ x=5
 
$ y=10
$ export y
 
$ echo $x $y
5 10
 
$ awk -v val=$x &#39;{print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]}&#39; OFS=&quot;\t&quot; score.txt
Marry   2143    78      89      87
Jack    2321    66      83      55
Tom     2122    48      82      81
Mike    2537    87      102     105
Bob     2415    40      62      72
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 17 May 2016 01:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A74/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A74/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sml&quot;&gt;sed命令&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#smlth&quot;&gt;s命令替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dgth&quot;&gt;多个替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ykhpp&quot;&gt;圆括号匹配&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#scyml&quot;&gt;sed常用命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cml&quot;&gt;c命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dml&quot;&gt;d命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pml&quot;&gt;p命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mldb&quot;&gt;命令打包&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#zh&quot;&gt;最后再来个工作中最常用的，sed截取日志中某个时间段的文本&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。&lt;/p&gt;

&lt;p&gt;之前了解了常用的几个统计读取日志的命令以及正则表达式,这节了解一下非常强大的两个命令,一个是sed,一个是awk,这两个命令能够完成绝大部分的关键词的取用和统计。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://coolshell.cn/articles/9104.html#more-9104&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大量的例子都是从这里搬运的，推荐大家看酷壳，个人觉得帮助到我很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namesmlseda&quot;&gt;&lt;a name=&quot;sml&quot;&gt;sed命令&lt;/a&gt;&lt;/h1&gt;

&lt;h3 id=&quot;a-namesmlthsa&quot;&gt;&lt;a name=&quot;smlth&quot;&gt;s命令替换&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;功能：管道流编辑器,它可以读指定的文件或者标准输入流,通过一系列的命名可以去修改读到的输入,然后再将修改后的输入进行输出。它可以对匹配的每行都进行处理，比如同时加上什么东西，替换什么东西，减少什么东西。&lt;br /&gt;
直接看例子：&lt;br /&gt;
测试文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat pets.txt
This is my cat
  my cat&#39;s name is betty
This is my dog
  my dog&#39;s name is frank
This is my fish
  my fish&#39;s name is george
This is my goat
  my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把匹配到my的地方全部换成Hao Chen’s
** （s表示替换命令，/my/表示匹配my，/Hao Chen’s/表示把匹配替换成Hao Chen’s，/g 表示一行上的替换所有的匹配)**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &quot;s/my/Hao Chen&#39;s/g&quot; pets.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一行最前面加点东西：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/^/#/g&#39; pets.txt
#This is my cat
#  my cat&#39;s name is betty
#This is my dog
#  my dog&#39;s name is frank
#This is my fish
#  my fish&#39;s name is george
#This is my goat
#  my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一行最后面加点东西：
** 可以看到sed 支持正则表达式，前一篇文章已经介绍了正则表达式，可以复习一下**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/$/ --- /g&#39; pets.txt
This is my cat ---
  my cat&#39;s name is betty ---
This is my dog ---
  my dog&#39;s name is frank ---
This is my fish ---
  my fish&#39;s name is george ---
This is my goat ---
  my goat&#39;s name is adam ---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只替换第3到第6行的文本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &quot;3,6s/my/your/g&quot; pets.txt
This is my cat
  my cat&#39;s name is betty
This is your dog
  your dog&#39;s name is frank
This is your fish
  your fish&#39;s name is george
This is my goat
  my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只替换每一行的第一个s：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/s/S/1&#39; my.txt
ThiS is my cat, my cat&#39;s name is betty
ThiS is my dog, my dog&#39;s name is frank
ThiS is my fish, my fish&#39;s name is george
ThiS is my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只替换每一行的第二个s：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/s/S/2&#39; my.txt
This iS my cat, my cat&#39;s name is betty
This iS my dog, my dog&#39;s name is frank
This iS my fish, my fish&#39;s name is george
This iS my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只替换第一行的第3个以后的s：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/s/S/3g&#39; my.txt
This is my cat, my cat&#39;S name iS betty
This is my dog, my dog&#39;S name iS frank
This is my fiSh, my fiSh&#39;S name iS george
This is my goat, my goat&#39;S name iS adam
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namedgtha&quot;&gt;&lt;a name=&quot;dgth&quot;&gt;多个匹配&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;如果我们需要一次替换多个模式，可参看下面的示例：（第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; my.txt
This is your cat, your cat&#39;s name is betty
This is your dog, your dog&#39;s name is frank
That is your fish, your fish&#39;s name is george
That is my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令等价于：（注：下面使用的是sed的-e命令行参数）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
sed -e &#39;1,3s/my/your/g&#39; -e &#39;3,$s/This/That/g&#39; my.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用&amp;amp;来当做被匹配的变量，然后可以在基本左右加点东西。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/my/[&amp;amp;]/g&#39; my.txt
This is [my] cat, [my] cat&#39;s name is betty
This is [my] dog, [my] dog&#39;s name is frank
This is [my] fish, [my] fish&#39;s name is george
This is [my] goat, [my] goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-nameykhppa&quot;&gt;&lt;a name=&quot;ykhpp&quot;&gt;圆括号匹配&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;使用圆括号匹配的示例：（圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\1,\2…）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;s/This is my \([^,]*\),.*is \(.*\)/\1:\2/g&#39; my.txt
cat:betty
dog:frank
fish:george
goat:adam
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个例子中的正则表达式有点复杂，解开如下（去掉转义字符）：
正则为：This is my ([^,]&lt;em&gt;),.&lt;/em&gt;is (.*)
匹配为：This is my (cat),……….is (betty)
然后：\1就是cat，\2就是betty&lt;/p&gt;

&lt;h3 id=&quot;a-namescymlseda&quot;&gt;&lt;a name=&quot;scyml&quot;&gt;sed常用命令&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;a命令和i命令
a命令就是append， i命令就是insert，它们是用来添加行的。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 其中的1i表明，其要在第1行前插入一行（insert）
$ sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt
This is my monkey, my monkey&#39;s name is wukong
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
This is my goat, my goat&#39;s name is adam

# 其中的1a表明，其要在最后一行后追加一行（append）
$ sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt
This is my cat, my cat&#39;s name is betty
This is my monkey, my monkey&#39;s name is wukong
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
This is my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以运用匹配来添加文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 注意其中的/fish/a，这意思是匹配到/fish/后就追加一行
$ sed &quot;/fish/a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
This is my monkey, my monkey&#39;s name is wukong
This is my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个例子是对每一行都挺插入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 注意其中的/fish/a，这意思是匹配到/fish/后就追加一行
$ sed &quot;/my/a ----&quot; my.txt
This is my cat, my cat&#39;s name is betty
----
This is my dog, my dog&#39;s name is frank
----
This is my fish, my fish&#39;s name is george
----
This is my goat, my goat&#39;s name is adam
----
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namecmlca&quot;&gt;&lt;a name=&quot;cml&quot;&gt;c命令&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;c 命令是替换匹配行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
第二行替换匹配行
$ sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt
This is my cat, my cat&#39;s name is bettyThis is my monkey, my monkey&#39;s name is wukong
This is my fish, my fish&#39;s name is george
This is my goat, my goat&#39;s name is adam
 
$ sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my monkey, my monkey&#39;s name is wukong
This is my goat, my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namedmlda&quot;&gt;&lt;a name=&quot;dml&quot;&gt;d命令&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;删除匹配行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ sed &#39;/fish/d&#39; my.txt
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my goat, my goat&#39;s name is adam
 
$ sed &#39;2d&#39; my.txt
This is my cat, my cat&#39;s name is betty
This is my fish, my fish&#39;s name is george
This is my goat, my goat&#39;s name is adam
第2行到结束都删除
$ sed &#39;2,$d&#39; my.txt
This is my cat, my cat&#39;s name is betty
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namepmlpa&quot;&gt;&lt;a name=&quot;pml&quot;&gt;p命令&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;打印命令&lt;/p&gt;

&lt;p&gt;你可以把这个命令当成grep式的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# 匹配fish并输出，可以看到fish的那一行被打了两遍，
# 这是因为sed处理时会把处理的信息输出
$ sed &#39;/fish/p&#39; my.txt
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
This is my fish, my fish&#39;s name is george
This is my goat, my goat&#39;s name is adam
 
# 使用n参数就好了
$ sed -n &#39;/fish/p&#39; my.txt
This is my fish, my fish&#39;s name is george
 
# 从一个模式到另一个模式
$ sed -n &#39;/dog/,/fish/p&#39; my.txt
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
 
#从第一行打印到匹配fish成功的那一行
$ sed -n &#39;1,/fish/p&#39; my.txt
This is my cat, my cat&#39;s name is betty
This is my dog, my dog&#39;s name is frank
This is my fish, my fish&#39;s name is george
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namemldba&quot;&gt;&lt;a name=&quot;mldb&quot;&gt;命令打包&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;第二个是cmd可以是多个，它们可以用分号分开，可以用大括号括起来作为嵌套命令。下面是几个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat pets.txt
This is my cat
  my cat&#39;s name is betty
This is my dog
  my dog&#39;s name is frank
This is my fish
  my fish&#39;s name is george
This is my goat
  my goat&#39;s name is adam
 
# 对3行到第6行，执行命令/This/d
$ sed &#39;3,6 {/This/d}&#39; pets.txt
This is my cat
  my cat&#39;s name is betty
  my dog&#39;s name is frank
  my fish&#39;s name is george
This is my goat
  my goat&#39;s name is adam
 
# 对3行到第6行，匹配/This/成功后，再匹配/fish/，成功后执行d命令
$ sed &#39;3,6 {/This/{/fish/d}}&#39; pets.txt
This is my cat
  my cat&#39;s name is betty
This is my dog
  my dog&#39;s name is frank
  my fish&#39;s name is george
This is my goat
  my goat&#39;s name is adam
 
# 从第一行到最后一行，如果匹配到This，则删除之；如果前面有空格，则去除空格
$ sed &#39;1,${/This/d;s/^ *//g}&#39; pets.txt
my cat&#39;s name is betty
my dog&#39;s name is frank
my fish&#39;s name is george
my goat&#39;s name is adam
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namezhseda&quot;&gt;&lt;a name=&quot;zh&quot;&gt;最后再来个工作中最常用的，sed截取日志中某个时间段的文本&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
sed -n &#39;/15:32:30/,/16:12:09/p&#39; access_log &amp;gt;log.txt
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 17 May 2016 01:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A73/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A73/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cc&quot;&gt;字符类操作系统字符分类&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#xbds&quot;&gt;[xxx]表达式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bsbh&quot;&gt;表示变化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hy&quot;&gt;还有一些tips&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#zyzf&quot;&gt;转义字符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dwd&quot;&gt;定位点&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xdf&quot;&gt;限定符（修饰数量）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fwxs&quot;&gt;范围修饰&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fdyzf&quot;&gt;非打印字符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mspp&quot;&gt;模式匹配&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#yxjsx&quot;&gt;优先级顺序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。&lt;/p&gt;
&lt;p&gt;之前介绍了查看文件过程中经常使用到的命令，但是我们在某些精细化的场景中也不能满足要求，比如单扣出某个字符，id等，所以这里我们要学习一个很重要的东西-正则表达式。我们先来了解一些正则表达式的语法。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://www.delorie.com/gnu/docs/grep/grep_toc.html#SEC_Contents&lt;/p&gt;

  &lt;p&gt;https://msdn.microsoft.com/zh-cn/library/az24scfc(v=vs.110).aspx&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namecca&quot;&gt;&lt;a name=&quot;cc&quot;&gt;字符类操作系统字符分类&lt;/a&gt;&lt;/h1&gt;

&lt;h3 id=&quot;a-namexbdsxxx-a&quot;&gt;&lt;a name=&quot;xbds&quot;&gt;[xxx] 表达式&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有一类表达式通过 &lt;strong&gt;[&lt;/strong&gt; 和 &lt;strong&gt;]&lt;/strong&gt; 将一系列字符包含在其中，如[a2],它的意思是匹配出 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;]&lt;/strong&gt; 包含的任意一个字符，比如[a2]就能匹配出含有a或2的数据。如果[]中包含的第一个字符是  &lt;strong&gt;^&lt;/strong&gt; ,就代表匹配任何不在 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;]&lt;/strong&gt; 中包含的字符。比如[^a2]就能匹配出任何不含有a或者不含有2的数据。&lt;/p&gt;

&lt;h3 id=&quot;a-namebsbha&quot;&gt;&lt;a name=&quot;bsbh&quot;&gt;表示变化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当表达一种区间时，我们才用连接符 &lt;strong&gt;-&lt;/strong&gt; 来连接字符表达，它可以匹配到范围中的任何一个字符，比如&lt;strong&gt;[&lt;/strong&gt;a-c&lt;strong&gt;]&lt;/strong&gt;可以匹配到a或者b或者c。
最后我们了解一些已经预先为我们考虑而设定好的一些特殊字符类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[:alnum:]
    &lt;ul&gt;
      &lt;li&gt;匹配英文大小写字符和数字(0-9,a-z.A-Z),等效于[:alpha:]和[:digit:]结果合集。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
  命令
  echo &quot;a\nB\nf\n1\n\!\n\t\n#&quot; |  grep --color=auto -e &quot;[[:alnum:]]&quot;
  结果：
      a
      B
      f
      1
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;[:alpha:]
    &lt;ul&gt;
      &lt;li&gt;代表任何英文大小写字符（A-Z, a-z）,等效于[:lower:]和[:upper:]结果合集。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;pre&gt;&lt;code&gt;
  命令
  echo &quot;a\nB\nf\n1\n\!\n\t\n#&quot; |  grep --color=auto -e &quot;[[:alpha:]]&quot;
  结果：
      a
      B
      f
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;[:blank:]
    &lt;ul&gt;
      &lt;li&gt;代表空白字符,代表空格键与[Tab]按键两者。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;pre&gt;&lt;code&gt;
  命令
  echo &quot;a\nB\nf\n1\n\!\n\t\n#&quot; |  grep --color=auto -e &quot;[[:blank:]]&quot;
  结果：
      \t
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;[:cntrl:]
    &lt;ul&gt;
      &lt;li&gt;代表键盘上面的控制按键,亦即包括 CR, LF, Tab, Del.. 等等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:digit:]
    &lt;ul&gt;
      &lt;li&gt;代表数字:0,1,2,3,4,5,6,7,8,9&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:graph:]
    &lt;ul&gt;
      &lt;li&gt;代表除了空格符合tab键之外的所有按键，实际就是等效于[:alnum:]和[:punct:]结果合集。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:lower:]
    &lt;ul&gt;
      &lt;li&gt;代表所有小写英文字母。a-z&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:print:]
    &lt;ul&gt;
      &lt;li&gt;代表任何可以被打印出来的字符,等效于[:alnum:]和[:punct]和空格&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:space:]
    &lt;ul&gt;
      &lt;li&gt;代表任何会产生空白的字符，包括空格键, [Tab], CR , 回车，换行等等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:upper:]
    &lt;ul&gt;
      &lt;li&gt;代表所有大写英文字母，A-Z&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[:xdigit:]
    &lt;ul&gt;
      &lt;li&gt;代表16进位的数字类型,因此包括: 0-9, A-F, a-f 的数字与字符&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-namehytipsa&quot;&gt;&lt;a name=&quot;hy&quot;&gt;还有一些tips&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果你使用 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;]&lt;/strong&gt; 中包含的字符有&lt;strong&gt;]&lt;/strong&gt;,那么一定把它放在首位，比如&lt;strong&gt;[]ab]&lt;/strong&gt;,会匹配&lt;strong&gt;]或者a或者b&lt;/strong&gt;,&lt;strong&gt;[][ab]&lt;/strong&gt;,会匹配&lt;strong&gt;]或者[或者a或者b&lt;/strong&gt;,&lt;strong&gt;[^]]&lt;/strong&gt;会匹配&lt;strong&gt;]&lt;/strong&gt;之外的所有字符。&lt;/p&gt;

&lt;h1 id=&quot;a-namezyzfa&quot;&gt;&lt;a name=&quot;zyzf&quot;&gt;转义符号&lt;/a&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;字符类别&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\c&lt;/td&gt;&lt;td&gt;控制字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\s&lt;/td&gt;&lt;td&gt;代表空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\S&lt;/td&gt;&lt;td&gt;代表不是空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\d&lt;/td&gt;&lt;td&gt;代表数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\D&lt;/td&gt;&lt;td&gt;代表不是数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\w&lt;/td&gt;&lt;td&gt;代表是单词,等价于[[:alnum]]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\W&lt;/td&gt;&lt;td&gt;代表不是单词,等价于[^[:alnum]]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\xhh&lt;/td&gt;&lt;td&gt;代表 16 进位的数字类型,因此包括: 0-9, A-F, a-f 的数字与字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\Oxxx&lt;/td&gt;&lt;td&gt;代表八进制的字符,亦即0-7&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;# &lt;a name=&quot;dwd&quot;&gt;定位点&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;锚标记&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;^&lt;/td&gt;&lt;td&gt;行首,比如:echo &quot;a\nB\nf\n1\n\!\n\t\n#\n \nba&quot; | grep --color=auto -e &quot;^a&quot; 只会匹配到a这一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\A&lt;/td&gt;&lt;td&gt;字符串的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;$&lt;/td&gt;&lt;td&gt;行尾,比如:echo &quot;a\nB\nf\n1\n\!\n\t\n#\n \nba&quot; | grep --color=auto -e &quot;a$&quot;会匹配到a,ba这两行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\Z&lt;/td&gt;&lt;td&gt;字符串的结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\b&lt;/td&gt;&lt;td&gt;单词的边界,比如&quot;\brat\b&quot;只能匹配&quot;rat&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\B&lt;/td&gt;&lt;td&gt;不是单词的边界,比如&quot;c\Breat\Be&quot;能匹配&quot;create&quot;,但是&quot;dirty \Brat&quot;不能匹配&quot;dirty rat&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\&amp;lt;&lt;/td&gt;&lt;td&gt;单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\&amp;gt;&lt;/td&gt;&lt;td&gt;单词的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;a-namexdfa&quot;&gt;&lt;a name=&quot;xdf&quot;&gt;限定符（修饰数量）&lt;/a&gt;&lt;/h1&gt;

&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;量词&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3}&lt;/td&gt;&lt;td&gt;只出现3次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,}&lt;/td&gt;&lt;td&gt;出现3次以上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,5}&lt;/td&gt;&lt;td&gt;出现3次,4次或者5次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,5}?&lt;/td&gt;&lt;td&gt;单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;?&lt;/td&gt;&lt;td&gt;等效于{0,1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;??&lt;/td&gt;&lt;td&gt;?的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*&lt;/td&gt;&lt;td&gt;出现0次或者多次,等价于{0,}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*?&lt;/td&gt;&lt;td&gt;*的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;+&lt;/td&gt;&lt;td&gt;出现1次或者多次,等价于{1,}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;+?&lt;/td&gt;&lt;td&gt;+的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;我们看到表中有几行解释是飞贪心模式，什么是非贪心模式呢？&lt;/p&gt;
&lt;p&gt;当 ? 紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。&lt;/p&gt;

&lt;h1 id=&quot;a-namefwxsa&quot;&gt;&lt;a name=&quot;fwxs&quot;&gt;范围修饰&lt;/a&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;范围&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; . &lt;/td&gt;&lt;td&gt;代表任何字符除开换行符(\n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(a|b)&lt;/td&gt;&lt;td&gt;a或者b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(?:...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a或者b或者c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;不是a或者不是b或者不是c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[a-q]&lt;/td&gt;&lt;td&gt;代表小写字母a~q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[A-Q]&lt;/td&gt;&lt;td&gt;代表大写字母A~Q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[0-7]&lt;/td&gt;&lt;td&gt;代表数字0~7,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;a-namefdyzfa&quot;&gt;&lt;a name=&quot;fdyzf&quot;&gt;非打印字符&lt;/a&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;范围&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; . &lt;/td&gt;&lt;td&gt;代表任何字符除开换行符(\n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(a|b)&lt;/td&gt;&lt;td&gt;a或者b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(?:...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a或者b或者c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;不是a或者不是b或者不是c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[a-q]&lt;/td&gt;&lt;td&gt;代表小写字母a~q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[A-Q]&lt;/td&gt;&lt;td&gt;代表大写字母A~Q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[0-7]&lt;/td&gt;&lt;td&gt;代表数字0~7,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;a-namemsppa&quot;&gt;&lt;a name=&quot;mspp&quot;&gt;模式匹配&lt;/a&gt;&lt;/h1&gt;

&lt;table&gt;
	&lt;tr&gt;&lt;th&gt;模式匹配&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?:模式)&lt;/td&gt;&lt;td&gt;	
与模式 匹配，但不保存匹配项；即不会存储匹配项以备将来之用。 这对于用“or”字符 (|) 组合模式部件的情况很有用。&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?=模式)&lt;/td&gt;&lt;td&gt;	
正预测先行。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?!模式)&lt;/td&gt;&lt;td&gt;	
负预测先行。 匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;a-nameyxjsxa&quot;&gt;&lt;a name=&quot;yxjsx&quot;&gt;优先级顺序&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;正则表达式的计算方式与算术表达式非常类似；即从左到右进行计算，并遵循优先级顺序。
下表按从高到低的顺序包含了正则表达式运算符的优先级顺序。&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;运算符&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; \ &lt;/td&gt;&lt;td&gt;转义符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(), (?:), (?=), []&lt;/td&gt;&lt;td&gt;括号和中括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*、+、?、{n}、{n,}、{n,m}&lt;/td&gt;&lt;td&gt;限定符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;^、$、\任何元字符&lt;/td&gt;&lt;td&gt;定位点和序列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;|&lt;/td&gt;&lt;td&gt;替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Mon, 09 May 2016 21:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/09/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A72/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/09/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A72/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
  </channel>
</rss>
