<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io/</link>
    <atom:link href="http://dunnohe.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 16 May 2016 20:24:27 +0800</pubDate>
    <lastBuildDate>Mon, 16 May 2016 20:24:27 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。&lt;/p&gt;
&lt;p&gt;之前介绍了查看文件过程中经常使用到的命令，但是我们在某些精细化的场景中也不能满足要求，比如单扣出某个字符，id等，所以这里我们要学习一个很重的东西，就是正则表达式。我们先来了解一些正则表达式的语法。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;操作系统字符分类&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;特殊符号&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:alnum:]&lt;/td&gt;&lt;td&gt;代表英文大小写字符及数字,亦即0-9, A-Z, a-z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:alpha:]&lt;/td&gt;&lt;td&gt;代表任何英文大小写字符,亦即 A-Z, a-z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:blank:]&lt;/td&gt;&lt;td&gt;代表空格键与[Tab]按键两者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:cntrl:]&lt;/td&gt;&lt;td&gt;代表键盘上面的控制按键,亦即包括 CR, LF, Tab, Del.. 等等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:digit:]&lt;/td&gt;&lt;td&gt;代表数字，即0-9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:graph:]&lt;/td&gt;&lt;td&gt;除了空格符 (空格键不 [Tab] 按键) 外的其他所有按键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:lower:]&lt;/td&gt;&lt;td&gt;代表小写字符,亦即 a-z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:print:]&lt;/td&gt;&lt;td&gt;代表任何可以被打印出来的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[:punct:]&lt;/td&gt;&lt;td&gt;代表标点符号,亦即:&quot; &#39; ? ! ; : # $...&lt;/td&gt;
&lt;/tr&gt;   
&lt;tr&gt;
	&lt;td&gt;[:upper:]&lt;/td&gt;&lt;td&gt;代表大写字符,亦即 A-Z&lt;/td&gt;
&lt;/tr&gt;  
&lt;tr&gt;
	&lt;td&gt;[:space:]&lt;/td&gt;&lt;td&gt;任何会产生空白的字符,包括空格键, [Tab], CR 等等&lt;/td&gt;
&lt;/tr&gt;  
&lt;tr&gt;
	&lt;td&gt;[:xdigit:]&lt;/td&gt;&lt;td&gt;代表 16 进位的数字类型,因此包括: 0-9, A-F, a-f 的数字与字符&lt;/td&gt;
&lt;/tr&gt;  
&lt;/table&gt;
&lt;p&gt;# 转义符号&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;字符类别&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\c&lt;/td&gt;&lt;td&gt;控制字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\s&lt;/td&gt;&lt;td&gt;代表空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\S&lt;/td&gt;&lt;td&gt;代表不是空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\d&lt;/td&gt;&lt;td&gt;代表数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\D&lt;/td&gt;&lt;td&gt;代表不是数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\w&lt;/td&gt;&lt;td&gt;代表是单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\W&lt;/td&gt;&lt;td&gt;代表不是单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\xhh&lt;/td&gt;&lt;td&gt;代表 16 进位的数字类型,因此包括: 0-9, A-F, a-f 的数字与字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\Oxxx&lt;/td&gt;&lt;td&gt;代表八进制的字符,亦即0-7&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;# 定位点&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;锚标记&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;^&lt;/td&gt;&lt;td&gt;行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\A&lt;/td&gt;&lt;td&gt;字符串的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;$&lt;/td&gt;&lt;td&gt;行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\Z&lt;/td&gt;&lt;td&gt;字符串的结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\b&lt;/td&gt;&lt;td&gt;单词的边界&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\B&lt;/td&gt;&lt;td&gt;不是单词的边界&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\&amp;lt;&lt;/td&gt;&lt;td&gt;单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;\&amp;gt;&lt;/td&gt;&lt;td&gt;单词的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-2&quot;&gt;限定符（修饰数量）&lt;/h1&gt;

&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;量词&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3}&lt;/td&gt;&lt;td&gt;只出现3次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,}&lt;/td&gt;&lt;td&gt;出现3次以上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,5}&lt;/td&gt;&lt;td&gt;出现3次,4次或者5次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;{3,5}?&lt;/td&gt;&lt;td&gt;单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;?&lt;/td&gt;&lt;td&gt;等效于{0,1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;??&lt;/td&gt;&lt;td&gt;?的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*&lt;/td&gt;&lt;td&gt;出现0次或者多次,等价于{0,}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*?&lt;/td&gt;&lt;td&gt;*的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;+&lt;/td&gt;&lt;td&gt;出现1次或者多次,等价于{1,}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;+?&lt;/td&gt;&lt;td&gt;+的非贪心模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;我们看到表中有几行解释是飞贪心模式，什么是非贪心模式呢？&lt;/p&gt;
&lt;p&gt;当 ? 紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;范围修饰&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;范围&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; . &lt;/td&gt;&lt;td&gt;代表任何字符除开换行符(\n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(a|b)&lt;/td&gt;&lt;td&gt;a或者b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(?:...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a或者b或者c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;不是a或者不是b或者不是c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[a-q]&lt;/td&gt;&lt;td&gt;代表小写字母a~q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[A-Q]&lt;/td&gt;&lt;td&gt;代表大写字母A~Q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[0-7]&lt;/td&gt;&lt;td&gt;代表数字0~7,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-4&quot;&gt;非打印字符&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;范围&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; . &lt;/td&gt;&lt;td&gt;代表任何字符除开换行符(\n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(a|b)&lt;/td&gt;&lt;td&gt;a或者b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(?:...)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a或者b或者c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;不是a或者不是b或者不是c，只能匹配其中一个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[a-q]&lt;/td&gt;&lt;td&gt;代表小写字母a~q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[A-Q]&lt;/td&gt;&lt;td&gt;代表大写字母A~Q,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;[0-7]&lt;/td&gt;&lt;td&gt;代表数字0~7,只出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-5&quot;&gt;模式匹配&lt;/h1&gt;

&lt;table&gt;
	&lt;tr&gt;&lt;th&gt;模式匹配&lt;/th&gt;&lt;th&gt;代表意义&lt;/th&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?:模式)&lt;/td&gt;&lt;td&gt;	
与模式 匹配，但不保存匹配项；即不会存储匹配项以备将来之用。 这对于用“or”字符 (|) 组合模式部件的情况很有用。&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?=模式)&lt;/td&gt;&lt;td&gt;	
正预测先行。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;(?!模式)&lt;/td&gt;&lt;td&gt;	
负预测先行。 匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-6&quot;&gt;优先级顺序&lt;/h1&gt;
&lt;p&gt;正则表达式的计算方式与算术表达式非常类似；即从左到右进行计算，并遵循优先级顺序。
下表按从高到低的顺序包含了正则表达式运算符的优先级顺序。&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
	&lt;th&gt;运算符&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt; \ &lt;/td&gt;&lt;td&gt;转义符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;(), (?:), (?=), []&lt;/td&gt;&lt;td&gt;括号和中括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;*、+、?、{n}、{n,}、{n,m}&lt;/td&gt;&lt;td&gt;限定符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;^、$、\任何元字符&lt;/td&gt;&lt;td&gt;定位点和序列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
	&lt;td&gt;|&lt;/td&gt;&lt;td&gt;替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Mon, 09 May 2016 21:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/09/%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A72/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/09/%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A72/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。
&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;筛选命令&lt;/h1&gt;

&lt;h2 id=&quot;cut&quot;&gt;cut命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能：截取结果
选项参数：
-d :后面接分隔字符。与 -f 一起使用;
-f :依据 -d 的分隔字符将一段讯息分割成为数段,用 -f 取出第几段的意思; 
-c :以字符 (characters) 的单位取出固定字符区间;

eg:
cut -d&#39;分隔字符&#39; -f fields &amp;lt;==用与有特定分隔字符
cut -c 字符区间 &amp;lt;==用亍排列整齐的讯息
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;grep&quot;&gt;grep命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能：筛选结果
选项参数：
-A num 	把每处匹配的后面num几行打出来
-B num  把每处匹配的前面几行打出来
-C num  等效于 -A num -B num
-c 把匹配的个数打出来
--color=auto 把匹配部分的颜色打出来
-e pattern pattern是正则表达式，符合的打出来
-i 不考虑大小写来匹配
-m num 最大匹配次数
-n 把行号打印出来
-v 反向匹配
-o 正则
eg:
grep -nC 2 -i -m 3 -color=auto &quot;exception&quot; error.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;sort&quot;&gt;sort命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能：排序
选项参数:
-b 忽略开头的空格
-d 按照字典顺序排序
-f 忽略大小写
-g 一般的数字排序
-i 只考虑能被打印出的字符
-M 按照月份排序
-n 根据数字string类型排序
-r 结果反向
-c 检测input是不是已经排序了，如果是就不再排序了
eg:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;# 统计命令
## uniq命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
功能：结果去重
选项参数:
-c 打印出每项对应的数目
-d 仅仅输出input中重复的行
-u 仅仅打印出input没有重复的行
-i 忽略大小写字符的不同
eg:
cat testsort | uniq
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;wc&quot;&gt;wc命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能：统计个数
选项参数:
-c 统计打印出来的字节个数
-l 统计打印出来的行数
-m 统计打印出来的字符个数
-w 统计打印出来的单词个数
eg:
cat testsort | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tee&quot;&gt;tee命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能：打印输出时同时把结果写入文件中
选项参数:
-a 通过append的方式追加到文件中
eg:
cat testsort| sort -g | uniq | wc -m | tee -a test 结果会打印出来
cat test 就可以看到结果
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;字符串替换命令&lt;/h1&gt;

&lt;h2 id=&quot;tr&quot;&gt;tr命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
功能:替换字符
语法:
tr [-Ccsu] string1 string2
tr [-Ccu] -d string1
tr [-Ccu] -s string1
tr [-Ccu] -ds string1 string2
选项参数:
-c 统计打印出来的字节个数
-l 统计打印出来的行数
-m 统计打印出来的字符个数
-w 统计打印出来的单词个数
eg:
把如下输出
1
2
3
转化成 1,2,3
echo &quot;1\n2\n3&quot; | tr &quot;\r\n&quot; &quot;,&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xargs&quot;&gt;xargs命令&lt;/h2&gt;
&lt;p&gt;将管道前面的内容作为xargs后面命令的参数,如果xargs后面没有跟命令,那么默认是echo。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
功能:将管道前面的内容作为xargs后面命令的参数,如果xargs后面没有跟命令,那么默认是echo。
语法:
xargs [-0epn] command
选项参数:
-0 :如果输入的 stdin 含有特殊字符,例如 `, \, 空格键等等字符时,这个 -0 参数可以将
他还原成一般字符。这个参数可以用于特殊状态!
-e :这个是 EOF (end of file) 的意思。后面可以接一个字符串,当 xargs分析到这个字符串时,就会停止继续工作!
-p :在执行每个指令的argument 时,都会询问使用者是否执行该命令，输入y执行，输入n不执行;
-n :后面接次数,每次 command 指令执行时,要使用几个参数的意思。
eg:
echo &quot;1\n2\n3&quot; | xargs
echo &quot;1\n2\n3\n\\&quot;  | xargs  #打印不出\字符
echo &quot;1\n2\n3\n\\&quot;  | xargs -0  #打印的出\字符
echo &quot;1\n2\n3&quot; | xargs -E 2  #因为2作为终结符，所以只会打印出1
echo &quot;1\n2\n3\n\\&quot;  | xargs  -n 2 #按照2个参数一组依次执行
echo &quot;1\n2\n3\n\\&quot;  | xargs -n1 -p #一次询问你是否打印单个数字
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 09 May 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/09/%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A71/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/09/%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A71/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;reentrantlock&quot;&gt;ReentrantLock(可重入锁)&lt;/h1&gt;
&lt;p&gt;# 介绍
重入锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个ReentrantLock的拥有者是最近一次使用该锁lock了却还没有unlock的线程。&lt;/li&gt;
  &lt;li&gt;如果一个线程成功的lock了，方法会成功返回，同时该线程会获得锁。如果该线程已经拥有该锁，再调用lock方法，lock方法会立马返回。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重要的方法&lt;/p&gt;

&lt;p&gt;public void lock()&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得锁
    &lt;ul&gt;
      &lt;li&gt;如果该锁没有被其他的线程持有，则该方法会立马返回，调用该方法的线程持有该锁，并且lock hold count(锁持有数)设置成1。&lt;/li&gt;
      &lt;li&gt;如果该线程已经拥有该锁，则该方法立马返回，且lock hold count（锁持有数）增加1。&lt;/li&gt;
      &lt;li&gt;如果该锁已经被其他线程持有，那么当前线程将会block直到获得该锁。获得的那个时候lock hold count（锁持有数）会被设置成1。（可以说明该锁是“独占的”，不同线程只能有一个线程占有）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public void lockInterruptibly() throws InterruptedException&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得锁除非当前线程被打断
    &lt;ul&gt;
      &lt;li&gt;如果该锁没有被其他的线程持有，则该方法会立马返回，调用该方法的线程持有该锁，并且lock hold count(锁持有数)设置成1。&lt;/li&gt;
      &lt;li&gt;如果该线程已经拥有该锁，则该方法立马返回，且lock hold count（锁持有数）增加1。&lt;/li&gt;
      &lt;li&gt;如果这个锁已经被其他线程持有，那么当前线程将不会被线程调度，同时当前线程会进入休眠状态直到以下两种情况之一发生：
        &lt;ul&gt;
          &lt;li&gt;当前线程获得锁&lt;/li&gt;
          &lt;li&gt;当前线程被Interrupt&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A06-reentrantlock/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A06-reentrantlock/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;synchronized&quot;&gt;synchronized&lt;/h1&gt;
&lt;p&gt;## 先来看看jsr133中lock的语义&lt;/p&gt;

&lt;p&gt;There are multiple mechanisms for communicating between threads. The most basic of these methods is synchronization, which is implemented using monitors. Each object is associated with a monitor, which a thread can lock or unlock. Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor.&lt;/p&gt;
&lt;p&gt;A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation.&lt;/p&gt;
&lt;p&gt;The synchronized statement computes a reference to an object; it then attempts to perform a lock action on that object’s monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.
A synchronized method automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static, it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method’s body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.&lt;/p&gt;

&lt;p&gt;The semantics neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that don’t deadlock, if necessary.&lt;/p&gt;

&lt;p&gt;Other mechanisms, such as reads and writes of volatile variables and classes provided in the java.util.concurrent package, provide alternative mechanisms for synchronization.&lt;/p&gt;

&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;
&lt;pre&gt;
package com.github.dunno.concurrent.sync;

import org.junit.Test;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Created by liang.he on 16/1/16.
 */
public class TestSync {
	//类锁：在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段
	//对象锁：在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段
	//私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）

	private Integer lock = new Integer(1);

	private Integer lock2 = new Integer(2);

	private final static Integer staticLock = new Integer(3);

	//无锁
	public void noLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;noLockMethod start! start:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;noLockMethod-lock:&quot; + lock2);
				System.out.println(&quot;noLockMethod-lock:&quot; + lock);
				System.out.println(&quot;noLockMethod-lock:&quot; + staticLock);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;noLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//对象锁1
	public synchronized void objectLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;objectLockMethod start! start:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;objectLockMethod-lock:&quot; + lock2);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;objectLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//对象锁2
	public void objectLockMethod2() {
		synchronized (this) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;objectLockMehtod2 start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;objectLockMehtod2-lock:&quot; + lock2);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;objectLockMehtod2 end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//私有锁 锁变量1
	public void privateLockMethod() {
		synchronized (lock) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;privateLockMethod1-lock:&quot; + lock2);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//私有锁 锁变量2
	public void privateLockMethod2() {
		synchronized (lock2) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod2 start! mills:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;privateLockMethod2-lock:&quot; + lock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;privateLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	//类锁
	public synchronized static void classLockMethod() {
		long start = System.currentTimeMillis();
		System.out.println(&quot;classLockMethod start! mills:&quot; + start);
		int sleep = 2;
		while (sleep &amp;gt; 0) {
			try {
				Thread.sleep(1000);
				System.out.println(&quot;classLockMethod-lock:&quot; + staticLock);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			sleep --;
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;classLockMethod end! end:&quot; + end + &quot; cost:&quot; + (end - start));
	}

	//类锁
	public static void classLockMethod2() {
		synchronized (TestSync.class) {
			long start = System.currentTimeMillis();
			System.out.println(&quot;classLockMethod2 start! mills:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;classLockMethod2-lock:&quot; + staticLock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;classLockMethod2 end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		}
	}

	private ReentrantLock reentrantLock = new ReentrantLock();

	//独占锁
	public void reentrantLock() {
		try {
			reentrantLock.lock();
			long start = System.currentTimeMillis();
			System.out.println(&quot;reentrantLock start! start:&quot; + start);
			int sleep = 2;
			while (sleep &amp;gt; 0) {
				try {
					Thread.sleep(1000);
					System.out.println(&quot;reentrantLock-lock:&quot; + lock2);
					System.out.println(&quot;reentrantLock-lock:&quot; + lock);
					System.out.println(&quot;reentrantLock-lock:&quot; + staticLock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				sleep --;
			}
			long end = System.currentTimeMillis();
			System.out.println(&quot;reentrantLock end! end:&quot; + end + &quot; cost:&quot; + (end - start));
		} finally {
			reentrantLock.unlock();
		}
	}

	private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();


	public void readWriteLock() {

	}

	//测试私有锁锁不同变量是否会有竞争
	//结论:
	//只打开注释1,注释2,可以说明“当私有锁监视同一资源会竞争,等待其中一个资源释放,当监视的资源不是同一个不会产生竞争”
	//只打开注释3,注释4,可以说明“对象锁会互相竞争，等待另一个方法结束”
	//只打开注释5,注释6,可以说明&quot;类锁会互相竞争，等待另一个释放资源&quot;
	//只打开注释1,注释6,打开注释1,注释5,可以说明&quot;不同的锁不会竞争&quot;
	//只打开注释1,注释7,3-7或者5-7,可以说明&quot;无锁变量不会和锁变量竞争&quot;
	//不同类的锁不会竞争
	@Test
	public void test1() {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				Thread thread1 = new Thread(new Runnable() {
					@Override
					public void run() {

						//privateLockMethod();//注释1
						//objectLockMethod();//注释3
						//classLockMethod();//注释5
						reentrantLock();//注释8
					}
				});
				Thread thread2 = new Thread(new Runnable() {
					@Override
					public void run() {

						//privateLockMethod2();//注释2
						//objectLockMethod2();//注释4
						//classLockMethod2();//注释6
						//noLockMethod();//注释7
						reentrantLock();//注释9
					}
				});
				thread1.start();
				thread2.start();

				try {
					thread1.join();
					thread2.join();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

			}
		});
		thread.start();
		try {
			thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

&lt;/pre&gt;
</description>
        <pubDate>Sun, 24 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A05-synchronized/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A05-synchronized/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;线程的睡眠&amp;amp;等待&amp;amp;让步&amp;amp;唤醒&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;yield()
    &lt;ul&gt;
      &lt;li&gt;发送请求告诉调度器“当前线程”让出当前对处理器资源的占用。调度器可以忽略该请求。&lt;/li&gt;
      &lt;li&gt;很少场景会使用到这个方法，该方法可能对于debug或者出于测试的目的的场景有些用处（就是没有什么卵用的意思）。&lt;/li&gt;
      &lt;li&gt;D大调&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;sleep(long millis)
    &lt;ul&gt;
      &lt;li&gt;当前的执行线程（注意是当前执行线程，比如如果你万一使用t1.sleep(1000),也不建议这么写，不一定会对t1起作用）进入休眠(暂停执行)。&lt;/li&gt;
      &lt;li&gt;使用该方法时并不会让出对象的监视器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wait(long timeout)
    &lt;ul&gt;
      &lt;li&gt;使“当前线程”等待直到其他线程调用了notify()或者notifyAll()方法。&lt;/li&gt;
      &lt;li&gt;“当前线程”必须是此时正在起作用的对象监视器的所有者。&lt;/li&gt;
      &lt;li&gt;该方法让“当前线程（以下用T表示）”等待同时释放对象监视器的锁，而且T在等待期间也不会再进行线程调度。除非发生以下一种情况：
        &lt;ul&gt;
          &lt;li&gt;其他线程调用notify()时,随机唤醒了T线程。&lt;/li&gt;
          &lt;li&gt;其他线程调用了notifyAll()&lt;/li&gt;
          &lt;li&gt;其他线程interrupts了T线程&lt;/li&gt;
          &lt;li&gt;指定的真实等待时间结束。当蚕食timeout是0时，那么则不会考虑timeout，线程T会一直等待直到被唤醒。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;线程可能不在上面四种情况下被唤醒，我们称为“spurious wakeup”,在实际操作中几乎不会发生。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wait()
    &lt;ul&gt;
      &lt;li&gt;wait()的实现是wait(0);&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;notify()
    &lt;ul&gt;
      &lt;li&gt;唤醒一个在该对象监视器上等待的单个线程。&lt;/li&gt;
      &lt;li&gt;唤醒的机制是随机唤醒。&lt;/li&gt;
      &lt;li&gt;一次wait方法只能使一个线程在该对象监视器等待。&lt;/li&gt;
      &lt;li&gt;被唤醒的线程不会开始处理程序直到当前线程释放了对这个对象监视器的锁。&lt;/li&gt;
      &lt;li&gt;这个方法应该被这个对象监视器的拥有者的这个线程调用。一个线程成为对象监视器的拥有者有以下三个方法：
        &lt;ul&gt;
          &lt;li&gt;通过执行一个这个对象的同步实例方法&lt;/li&gt;
          &lt;li&gt;通过执行锁住这个对象的同步块方法&lt;/li&gt;
          &lt;li&gt;对于Class类型的对象来说，通过执行这个类的一个静态的同步方法。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;一个线程在一个时刻只能拥有一个对象监视器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;notifyAll()
    &lt;ul&gt;
      &lt;li&gt;唤醒在此对象监视器上面的所有等待的线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A04-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85&%E8%AE%A9%E6%AD%A5&%E5%94%A4%E9%86%92/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A04-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85&%E8%AE%A9%E6%AD%A5&%E5%94%A4%E9%86%92/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;守护线程的创建和执行&lt;/h1&gt;
&lt;p&gt;## 介绍
java有一种线程叫守护线程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这种线程拥有非常低的执行权值且一般在其他线程在同一程序不执行时执行。&lt;/li&gt;
  &lt;li&gt;通过调用setDaemon(true);将该线程设置成守护线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Demo
验证一下1&lt;/p&gt;
&lt;pre&gt;
public class TestDaemonThread {

	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				int sleep = 2;

				while ( sleep &amp;gt; 0) {
					try {
						Thread.sleep(1000);
						System.out.println(Thread.currentThread().getName() + &quot;i have sleep 1 secends!&quot;);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sleep --;
				}

				System.out.println(Thread.currentThread().getName() + &quot;i &#39;m wake up&quot;);
			}
		});
		thread.setName(&quot;not daemon thread &quot;);

		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				int sleep = 5;

				while ( sleep &amp;gt; 0) {
					try {
						Thread.sleep(1000);
						System.out.println(Thread.currentThread().getName() + &quot;i have sleep 1 secends!&quot;);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sleep --;
				}

				System.out.println(Thread.currentThread().getName() + &quot;i &#39;m wake up&quot;);
			}
		});
		thread2.setName(&quot;daemon thread &quot;);
		thread2.setDaemon(true);

		thread.start();
		thread2.start();

		try {
			thread2.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(thread.getName() + &quot;pro &quot; + thread.getPriority());
		System.out.println(thread2.getName() + &quot;pro &quot; + thread2.getPriority());

	}
}
&lt;/pre&gt;
&lt;p&gt;上面代码中，我们执行两个线程，一个普通线程，sleep2秒，另一个线程是守护线程，sleep5秒，根据上面的例子，我们预测一下，普通线程执行2秒后，主线程就退出了。&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A03-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/24/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A03-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;打断线程&amp;amp;等待线程的终止&lt;/h1&gt;
&lt;p&gt;##打断线程demo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * Created by liang.he on 16/1/12.
 * 测试打断一个线程
 */
public class TestInterruptThread extends Thread{

	private boolean flag = true;

	@Override
	public void run() {
		while (true) {
			System.out.println(&quot;i&#39;m still running!&quot;);
			if (isInterrupted()) {
				System.out.println(&quot;The Prime Generator has been Interrupted&quot;);
				return;
			}
		}
	}

	public static void main(String[] args ) {
		TestInterruptThread task = new TestInterruptThread();
		task.start();
		try {
			Thread.sleep(5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		task.interrupt();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;等待线程的终止&lt;/h2&gt;

&lt;p&gt;调用线程的join()方法。&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A02-%E6%89%93%E6%96%AD%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/23/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A02-%E6%89%93%E6%96%AD%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
      <item>
        <title>Java多线程学习系列</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;创建线程&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;创建一个线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;实现Runnable接口
    &lt;pre&gt;
  public TestRunnable implements implements Runnable {
      @Override
      public void run() {
      }
  }
  new Thread(new TestRunnable()).start();
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;继承Thread类
    &lt;pre&gt;
  public class TestThread extends Thread {
      @Override
      public void run() {
      }
  }
  new TestThread().start();
  &lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;启动一个线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;启动一个线程
    &lt;pre&gt;
  new Thread().start();
  &lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;线程的状态&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;NEW 当线程创建之后但是还没有调用start方法时会是这个状态。&lt;/li&gt;
  &lt;li&gt;RUNNABLE 当线程正在JVM中执行时（但实际也有可能正在等待操作系统的其他资源，比如处理器资源），线程会被标记成该状态&lt;/li&gt;
  &lt;li&gt;BOLCKED 线程正在等待一个监视器锁或者进入同步块/方法，或者在调用Object.wait()方法之后重进入同步块/方法&lt;/li&gt;
  &lt;li&gt;WAITING 线程正在等待另一个线程执行完一个特定的动作时会标记成该状态，比如：一个线程被调用了Object.wait()会使它处于WAITING状态直到另一个线程调用了Object.notify()或者Object.notifyAll()唤醒该线程；或者该线程被调用了Object.join()等待另一个线程的终止时会处于WAITING状态。&lt;/li&gt;
  &lt;li&gt;TIMED_WAITING 在特定的时间内等待另一个线程。以下方法会产生该作用：
    &lt;ul&gt;
      &lt;li&gt;Thread.sleep&lt;/li&gt;
      &lt;li&gt;Object.wait with timeout&lt;/li&gt;
      &lt;li&gt;Thread.join with timeout&lt;/li&gt;
      &lt;li&gt;LockSupport.parkNanos&lt;/li&gt;
      &lt;li&gt;LockSupport.parkUntil&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TERMINATED 线程的终止状态，当线程完成它的执行时标记成该状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;startrun&quot;&gt;start和run的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;start的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
/**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
     * &lt;p&gt;
     * The result is that two threads are running concurrently: the
     * current thread (which returns from the call to the
     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
     * &lt;code&gt;run&lt;/code&gt; method).
     * &lt;p&gt;
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * @exception  IllegalThreadStateException  if the thread was already
     *               started.
     * @see        #run()
     * @see        #stop()
     */
    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

* run的实现
&lt;pre&gt;
	/**
     * If this thread was constructed using a separate
     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that
     * &lt;code&gt;Runnable&lt;/code&gt; object&#39;s &lt;code&gt;run&lt;/code&gt; method is called;
     * otherwise, this method does nothing and returns.
     * &lt;p&gt;
     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.
     *
     * @see     #start()
     * @see     #stop()
     * @see     #Thread(ThreadGroup, Runnable, String)
     */
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

* 方法的区别
	* start方法是一个线程开始执行的原因（所以我们应该通过调用start方法来启动一个线程，而不是run）
	* start方法至多启动同一个线程一次。
	* 线程再完成执行后，不会重新启动start方法。
	* start方法不会被“主线程”或者是虚拟机创建/设置的“系统态”线程调用（而是创建一个新线程来调用）。
	* run就是一个普通的方法，可以被重复调用。
&lt;/p&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/p&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 16 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/01/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/01/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A01-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>java多线程</category>
        
        
      </item>
    
  </channel>
</rss>
