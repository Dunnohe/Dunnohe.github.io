<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io/</link>
    <atom:link href="http://dunnohe.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 08 Aug 2016 10:51:05 +0800</pubDate>
    <lastBuildDate>Mon, 08 Aug 2016 10:51:05 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>JDK-命令行工具介绍4</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这一次总结的命令是**jinfo**，实际这个命令并不复杂，用的也不多，专门拿一个篇幅总结是想借着这个命令同时总结一下JVM常用的参数&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#Options&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjinfoa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jinfo命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
Usage:
    jinfo [option] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jinfo [option] &amp;lt;executable &amp;lt;core&amp;gt;
        (to connect to a core file)
    jinfo [option] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to remote debug server)

where &amp;lt;option&amp;gt; is one of:
    -flag &amp;lt;name&amp;gt;         输出指定JVM参数的值
    -flag [+|-]&amp;lt;name&amp;gt;    启动或者禁用JVM的参数
    -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; 设置JVM参数的值
    -flags               输出所有jvm参数的值
    -sysprops            输出系统属性
    &amp;lt;no option&amp;gt;    输出上面两个属性说有结果
    -h | -help           输出使用用法
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;jinfo--flags-10536&quot;&gt;示例: jinfo -flags 10536&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
部分输出...

Attaching to process ID 10536, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.76-b04

-Dapp.key=hotel.HotelCampaignsWeb -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 
-Djava.io.tmpdir=/tmp -Djava.net.preferIPv6Addresses=false -Xdebug -Xnoagent
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjvm-optionsa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;behavioral-options&quot;&gt;Behavioral Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-AllowUserSignalHandlers&lt;/td&gt;
        &lt;td&gt;Do not complain if the application installs signal handlers. (Relevant to Solaris and Linux only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AltStackSize=16384&lt;/td&gt;
        &lt;td&gt;Alternate signal stack size (in Kbytes). (Relevant to Solaris only, removed from 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-DisableExplicitGC&lt;/td&gt;
        &lt;td&gt;By default calls to System.gc() are enabled (-XX:-DisableExplicitGC). Use -XX:+DisableExplicitGC to disable
            calls to System.gc(). Note that the JVM still performs garbage collection when necessary.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+FailOverToOldVerifier&lt;/td&gt;
        &lt;td&gt;Fail over to old verifier when the new type checker fails. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+HandlePromotionFailure&lt;/td&gt;
        &lt;td&gt;The youngest generation collection does not require a guarantee of full promotion of all live objects.
            (Introduced in 1.4.2 update 11) [5.0 and earlier: false.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+MaxFDLimit&lt;/td&gt;
        &lt;td&gt;Bump the number of file descriptors to max. (Relevant&amp;nbsp; to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:PreBlockSpin=10&lt;/td&gt;
        &lt;td&gt;Spin count variable for use with -XX:+UseSpinning. Controls the maximum spin iterations allowed before
            entering operating system thread synchronization code. (Introduced in 1.4.2.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-RelaxAccessControlCheck&lt;/td&gt;
        &lt;td&gt;Relax the access control checks in the verifier. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+ScavengeBeforeFullGC&lt;/td&gt;
        &lt;td&gt;Do young generation GC prior to a full GC. (Introduced in 1.4.1.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseAltSigs&lt;/td&gt;
        &lt;td&gt;Use alternate signals instead of SIGUSR1 and SIGUSR2 for VM internal signals. (Introduced in 1.3.1 update 9,
            1.4.1. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBoundThreads&lt;/td&gt;
        &lt;td&gt;Bind user level threads to kernel threads. (Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseConcMarkSweepGC&lt;/td&gt;
        &lt;td&gt;Use concurrent mark-sweep collection for the old generation. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseGCOverheadLimit&lt;/td&gt;
        &lt;td&gt;Use a policy that limits the proportion of the VM&#39;s time that is spent in GC before an OutOfMemory error is
            thrown. (Introduced in 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLWPSynchronization&lt;/td&gt;
        &lt;td&gt;Use LWP-based instead of thread based synchronization. (Introduced in 1.4.0. Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for scavenges. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelOldGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for the full collections. Enabling this option automatically sets
            -XX:+UseParallelGC. (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSerialGC&lt;/td&gt;
        &lt;td&gt;Use serial garbage collection. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSpinning&lt;/td&gt;
        &lt;td&gt;Enable naive spinning on Java monitor before entering operating system thread synchronizaton code. (Relevant
            to 1.4.2 and 5.0 only.) [1.4.2, multi-processor Windows platforms: true]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseTLAB&lt;/td&gt;
        &lt;td&gt;Use thread-local object allocation (Introduced in 1.4.0, known as UseTLE prior to that.) [1.4.2 and earlier,
            x86 or with -client: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseSplitVerifier&lt;/td&gt;
        &lt;td&gt;Use the new type checker with StackMapTable attributes. (Introduced in 5.0.)[5.0: false]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseThreadPriorities&lt;/td&gt;
        &lt;td&gt;Use native thread priorities.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseVMInterruptibleIO&lt;/td&gt;
        &lt;td&gt;Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. (Introduced in 6. Relevant to
            Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;garbage-first-g1-garbage-collection-options&quot;&gt;Garbage First (G1) Garbage Collection Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseG1GC&lt;/td&gt;
        &lt;td&gt;Use the Garbage First (G1) Collector&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxGCPauseMillis=n&lt;/td&gt;
        &lt;td&gt;Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to
            achieve it.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitiatingHeapOccupancyPercent&lt;span id=&quot;MainContent&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a
            concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A
            value of 0 denotes &#39;do constant GC cycles&#39;. The default value is 45.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. The default value is 2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size. The default value is 8.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Maximum value for tenuring threshold. The default value is 15.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of threads used during parallel phases of the garbage collectors. The default value varies
            with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ConcGCThreads=n&lt;/td&gt;
        &lt;td&gt;Number of threads concurrent garbage collectors will use. The default value varies with the platform on
            which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1ReservePercent&lt;span id=&quot;MainContent2&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure.
            The default value is 10.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1HeapRegionSize&lt;span id=&quot;MainContent3&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual
            sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The
            minimum value is 1Mb and the maximum value is 32Mb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;performance-options&quot;&gt;Performance Options&lt;/h2&gt;
&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AggressiveOpts&lt;/td&gt;
        &lt;td&gt;Turn on point performance compiler optimizations that are expected to be default in upcoming releases.
            (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:CompileThreshold=10000&lt;/td&gt;
        &lt;td&gt;Number of method invocations/branches before compiling [-client: 1,500]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LargePageSizeInBytes=4m&lt;/td&gt;
        &lt;td&gt;Sets the large page size used for the Java heap. (Introduced in 1.4.0 update 1.) [amd64: 2m.]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxHeapFreeRatio=70&lt;/td&gt;
        &lt;td&gt;Maximum percentage of heap free after GC to avoid shrinking.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxNewSize=size&lt;/td&gt;
        &lt;td&gt;Maximum size of new generation (in bytes). Since 1.4, MaxNewSize is computed as a function of NewRatio.
            [1.3.1 Sparc: 32m; 1.3.1 x86: 2.5m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxPermSize=64m&lt;/td&gt;
        &lt;td&gt;Size of the Permanent Generation.&amp;nbsp; [5.0 and newer: 64 bit VMs are scaled 30% larger; 1.4 amd64: 96m;
            1.3.1 -client: 32m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MinHeapFreeRatio=40&lt;/td&gt;
        &lt;td&gt;Minimum percentage of heap free after GC to avoid expansion.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=2&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. [Sparc -client: 8; x86 -server: 8; x86 -client: 12.]-client: 4 (1.3) 8
            (1.3.1+), x86: 12]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewSize=2m&lt;/td&gt;
        &lt;td&gt;Default size of new generation (in bytes) [5.0 and newer: 64 bit VMs are scaled 30% larger; x86: 1m; x86,
            5.0 and older: 640k]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ReservedCodeCacheSize=32m&lt;/td&gt;
        &lt;td&gt;Reserved code cache size (in bytes) - maximum code cache size. [Solaris 64-bit, amd64, and -server x86:
            2048m; in 1.5.0_06 and earlier, Solaris 64-bit and amd64: 1024m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=8&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size [Solaris amd64: 6; Sparc in 1.3.1: 25; other Solaris platforms in 5.0 and
            earlier: 32]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:TargetSurvivorRatio=50&lt;/td&gt;
        &lt;td&gt;Desired percentage of survivor space used after scavenge.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ThreadStackSize=512&lt;/td&gt;
        &lt;td&gt;Thread Stack Size (in Kbytes). (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior
            in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBiasedLocking&lt;/td&gt;
        &lt;td&gt;Enable biased locking. For more details, see this &lt;a href=&quot;/technetwork/java/tuning-139912.html#section4.2.5&quot;&gt;tuning example&lt;/a&gt;. (Introduced in 5.0 update
            6.) [5.0: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
        &lt;td&gt;Use optimized versions of Get&amp;lt;Primitive&amp;gt;Field.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseISM&lt;/td&gt;
        &lt;td&gt;Use Intimate Shared Memory. [Not accepted for non-Solaris platforms.] For details, see &lt;a href=&quot;/technetwork/java/ism-139376.html&quot;&gt;Intimate Shared Memory&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLargePages&lt;/td&gt;
        &lt;td&gt;Use large page memory. (Introduced in 5.0 update 5.) For details, see &lt;a href=&quot;/technetwork/java/javase/tech/largememory-jsp-137182.html&quot;&gt;Java Support for Large Memory Pages&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseMPSS&lt;/td&gt;
        &lt;td&gt;Use Multiple Page Size Support w/4mb pages for the heap. Do not use with ISM as this replaces the need for
            ISM. (Introduced in 1.4.0 update 1, Relevant to Solaris 9 and newer.) [1.4.1 and earlier: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseStringCache&lt;/td&gt;
        &lt;td&gt;Enables caching of commonly allocated strings.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchLines=1&lt;/td&gt;
        &lt;td&gt;Number of cache lines to load after the last object allocation using prefetch instructions generated in JIT
            compiled code. Default values are 1 if the last allocated object was an instance and 3 if it was an array.
            &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchStyle=1&lt;/td&gt;
        &lt;td&gt;Generated code style for prefetch instructions.&lt;br /&gt; 0 - no prefetch instructions are generate*d*,&lt;br /&gt; 1 -
            execute prefetch instructions after each allocation,&lt;br /&gt; 2 - use TLAB allocation watermark pointer to gate
            when prefetch instructions are executed.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedStrings&lt;/td&gt;
        &lt;td&gt;Use a byte[] for Strings which can be represented as pure ASCII. (Introduced in Java 6 Update 21 Performance
            Release) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
        &lt;td&gt;Optimize String concatenation operations where possible. (Introduced in Java 6 Update 20) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;debugging-options&quot;&gt;Debugging Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-CITime&lt;/td&gt;
        &lt;td&gt;Prints time spent in JIT Compiler. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ErrorFile=./hs_err_pid&amp;lt;pid&amp;gt;.log&lt;/td&gt;
        &lt;td&gt;If an error occurs, save the error data to this file. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-ExtendedDTraceProbes&lt;/td&gt;
        &lt;td&gt;Enable performance-impacting &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/vm/dtrace.html&quot;&gt;dtrace&lt;/a&gt;
            probes. (Introduced in 6. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:HeapDumpPath=./java_pid&amp;lt;pid&amp;gt;.hprof&lt;/td&gt;
        &lt;td&gt;Path to directory or filename for heap dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2 update 12, 5.0 update
            7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-HeapDumpOnOutOfMemoryError&lt;/td&gt;
        &lt;td&gt;Dump heap to file when java.lang.OutOfMemoryError is thrown. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2
            update 12, 5.0 update 7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnError=&quot;&amp;lt;cmd args&amp;gt;;&amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands on fatal error. (Introduced in 1.4.2 update 9.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnOutOfMemoryError=&quot;&amp;lt;cmd args&amp;gt;; &lt;br clear=&quot;none&quot; /&gt; &amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands when an OutOfMemoryError is first thrown. (Introduced in 1.4.2 update 12, 6)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintClassHistogram&lt;/td&gt;
        &lt;td&gt;Print a histogram of class instances on Ctrl-Break. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html&quot;&gt;jmap -histo&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintConcurrentLocks&lt;/td&gt;
        &lt;td&gt;Print java.util.concurrent locks in Ctrl-Break thread dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 6.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstack.html&quot;&gt;jstack -l&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCommandLineFlags&lt;/td&gt;
        &lt;td&gt;Print flags that appeared on the command line. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCompilation&lt;/td&gt;
        &lt;td&gt;Print message when a method is compiled.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGC&lt;/td&gt;
        &lt;td&gt;Print messages at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCDetails&lt;/td&gt;
        &lt;td&gt;Print more details at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCTimeStamps&lt;/td&gt;
        &lt;td&gt;Print timestamps at garbage collection. &lt;em&gt;Manageable&lt;/em&gt; (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintTenuringDistribution&lt;/td&gt;
        &lt;td&gt;Print tenuring age information.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintAdaptiveSizePolicy&lt;/td&gt;
        &lt;td&gt;Enables printing of information about adaptive generation sizing.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoading&lt;/td&gt;
        &lt;td&gt;Trace loading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoadingPreorder&lt;/td&gt;
        &lt;td&gt;Trace all classes loaded in order referenced (not loaded). (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassResolution&lt;/td&gt;
        &lt;td&gt;Trace constant pool resolutions. (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassUnloading&lt;/td&gt;
        &lt;td&gt;Trace unloading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceLoaderConstraints&lt;/td&gt;
        &lt;td&gt;Trace recording of loader constraints. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+PerfDataSaveToFile&lt;/td&gt;
        &lt;td&gt;Saves jvmstat binary data on exit.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of garbage collection threads in the young and old parallel garbage collectors. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedOops&lt;/td&gt;
        &lt;td&gt;Enables the use of compressed pointers (object references represented as 32 bit offsets instead of 64-bit
            pointers) for optimized 64-bit performance with Java heap sizes less than 32gb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
        &lt;td&gt;Pre-touch the Java heap during JVM initialization. Every page of the heap is thus demand-zeroed during
            initialization rather than incrementally during application execution.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchDistance=n&lt;/td&gt;
        &lt;td&gt;Sets the prefetch distance for object allocation. Memory about to be written with the value of new objects
            is prefetched into cache at this distance (in bytes) beyond the address of the last allocated object. Each
            Java thread has its own allocation point. The default value varies with the platform on which the JVM is
            running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InlineSmallCode=n&lt;/td&gt;
        &lt;td&gt;Inline a previously compiled method only if its generated native code size is less than this. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxInlineSize=35&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a method to be inlined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:FreqInlineSize=n&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a frequently executed method to be inlined. The default value varies with the
            platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LoopUnrollLimit=n&lt;/td&gt;
        &lt;td&gt;Unroll loop bodies with server compiler intermediate representation node count less than this value. The
            limit used by the server compiler is a function of this value, not the actual value. The default value
            varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitialTenuringThreshold=7&lt;/td&gt;
        &lt;td&gt;Sets the initial tenuring threshold for use in adaptive GC sizing in the parallel young collector. The
            tenuring threshold is the number of times an object survives a young collection before being promoted to the
            old, or tenured, generation.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Sets the maximum tenuring threshold for use in adaptive GC sizing. The current largest value is 15. The
            default value is 15 for the parallel collector and is 4 for CMS.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-Xloggc:&amp;lt;filename&amp;gt;&lt;/td&gt;
        &lt;td&gt;Log GC verbose output to specified file. The verbose output is controlled by the normal verbose GC flags.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseGCLogFileRotation&lt;/td&gt;
        &lt;td&gt;Enabled GC log rotation, requires -Xloggc.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NumberOfGClogFiles=1&lt;/td&gt;
        &lt;td&gt;Set the number of files to use when rotating logs, must be &amp;gt;= 1. The rotated log files will use the
            following naming scheme, &amp;lt;filename&amp;gt;.0, &amp;lt;filename&amp;gt;.1, ..., &amp;lt;filename&amp;gt;.n-1.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:GCLogFileSize=8K&lt;/td&gt;
        &lt;td&gt;The size of the log file at which point the log will be rotated, must be &amp;gt;= 8K.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍3</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstat -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstata&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jstat/jstat.png&quot; alt=&quot;jstat_输出&quot; /&gt;
一张图理解用法&lt;/p&gt;

&lt;h2 id=&quot;options&quot;&gt;options&lt;/h2&gt;
&lt;p&gt;使用jstat -options可以查看支持的选项&lt;/p&gt;

&lt;p&gt;$ jstat -options&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-class 显示classLoader的相关信息&lt;/li&gt;
  &lt;li&gt;-compiler 显示JIT编译的相关信息&lt;/li&gt;
  &lt;li&gt;-gc 显示gc相关信息&lt;/li&gt;
  &lt;li&gt;-gccapacity 显示gc容量信息&lt;/li&gt;
  &lt;li&gt;-gccause 显示垃圾回收相关信息，同时显示最后一次或者当前正在发生的垃圾回收的诱发原因&lt;/li&gt;
  &lt;li&gt;-gcnew 显示新生代信息&lt;/li&gt;
  &lt;li&gt;-gcnewcapacity 显示新生代容量和大小情况&lt;/li&gt;
  &lt;li&gt;-gcold 显示老年代和永久代情况&lt;/li&gt;
  &lt;li&gt;-gcoldcapacity 显示老年代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcpermcapacity 显示永久代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcutil 显示垃圾收集信息（这个用的最多）&lt;/li&gt;
  &lt;li&gt;-printcompilation 输出JIT编辑的方法信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcyjstat--gcutil-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstat -gcutil 输出解释&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;更多解释请看http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们这里介绍一下用的最多的命令的输出&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
       413446.8  40.62   0.00  58.40  36.91      -      -    174   17.153     1    1.798   18.952
       413447.8  40.62   0.00  58.51  36.91      -      -    174   17.153     1    1.798   18.952
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;S0 S0占对应分配空间的利用百分比（理解S0,S1需要关注一下垃圾回收算法）&lt;/li&gt;
  &lt;li&gt;S1 S1占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;E	新生代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;O	老年代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;P	永久代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;YGC	young gc的次数&lt;/li&gt;
  &lt;li&gt;YGCT	young gc花费的时间&lt;/li&gt;
  &lt;li&gt;FGC	full gc次数&lt;/li&gt;
  &lt;li&gt;FGCT	full gc花费的时间&lt;/li&gt;
  &lt;li&gt;GCT	Total garbage collection time.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Jdk 命令行工具介绍2</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout:     post
title:      “JDK-命令行工具介绍2”
subtitle:   “ &quot;了解jstack的用法&quot;”
date:       2016-07-31 18:58:00
author:     “Dunno”
header-img: “img/post-bg-2015.jpg”
tags:
    - JVM
—&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstack&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
https://dzone.com/articles/how-analyze-java-thread-dumps
https://gist.github.com/rednaxelafx/843622&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstacka&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack 根据指定的端口或者远程debug服务打印出线程栈跟踪信息。&lt;/p&gt;

&lt;h2 id=&quot;jstack--l-7124-pid7124&quot;&gt;jstack -l 7124 打出pid为7124的线程栈跟踪信息&lt;/h2&gt;

&lt;p&gt;部分输出:&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.76-b04 mixed mode):

&amp;quot;Thread-11-EventThread&amp;quot; daemon prio=5 tid=0x00007f8e9d8e0000 nid=0x32327 waiting on condition [0x0000700013bca000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  &amp;lt;0x00000007eef76740&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:494)

   Locked ownable synchronizers:
	- None

&amp;quot;Thread-11-SendThread(10.4.241.128:2181)&amp;quot; daemon prio=5 tid=0x00007f8e9d857000 nid=0x2a33f runnable [0x0000700013ac7000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:200)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
	- locked &amp;lt;0x00000007eef75488&amp;gt; (a sun.nio.ch.Util$2)
	- locked &amp;lt;0x00000007eef75478&amp;gt; (a java.util.Collections$UnmodifiableSet)
	- locked &amp;lt;0x00000007eef75358&amp;gt; (a sun.nio.ch.KQueueSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
	at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:349)
	at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1081)

   Locked ownable synchronizers:
	- None
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjstack--l-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;“Thread-11-EventThread”&lt;/strong&gt; 线程名字，当使用Thread类生成的线程，thread会被命名成Thread-(Number)，而使用ThreadFactory类生成的线程会被命名成pool-(number)-thread-(number)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt; 如果有这一列代表是守护线程，没有则说明不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prio=5&lt;/strong&gt; 代表该线程的权值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tid=0x00007f8e9d857000&lt;/strong&gt; 代表该线程唯一的id（线程id），这个id是java层面的id&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nid=0x2a33f&lt;/strong&gt; 本地线程id(Native thread ID)，这个id的值依赖于系统平台层面。
    &lt;ul&gt;
      &lt;li&gt;windows下，就是操作系统级别的线程id&lt;/li&gt;
      &lt;li&gt;Linux下，nid是线程的pid （这里多提一句，我们大多场景是在linux上，当出现问题时，我们先可以利用 top -Hp 找出不正常的线程pid，把pid转成16进制（因为nid是16进制），然后根据这个转好的pid立马找到线程在干嘛，通常就能发现问题，top的用法，可以回滚之前的top使用的总结。 ）&lt;/li&gt;
      &lt;li&gt;Solaris下，nid是thr_self()的返回值&lt;/li&gt;
      &lt;li&gt;在Mac OS下，可以认为是本地pthread_t的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;waiting on condition [0x0000700013bca000] / runnable [0x0000700013ac7000]&lt;/strong&gt; 线程此时的状态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最后一栏&lt;/strong&gt; 代表线程调用的完整的堆栈信息&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</guid>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这里我们先介绍用法比较简单的几个命令:jps,jmap,jhat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjpsa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jps JVM进程状态工具

→ jps 列出进程id和main函数名称
7124 AppMain
10829 Jps

→ jps -q 只输出进程id
7124
10807

→ jps -m 输出进程id和主函数参数
7124 AppMain org.codehaus.classworlds.Launcher -Didea.version=15.0 clean jetty:run -Pperformance
10857 Jps -m

→ jps -l 只输出进程id和主函数路径
7124 com.intellij.rt.execution.application.AppMain
10888 sun.tools.jps.Jps

→ jps -v 输出进程id和给传递给jvm的参数（最常用）
7124 AppMain -Xms2048m -Xmx2048m -XX:PermSize=1024m -XX:MaxPermSize=1024m -Dmaven.home=/usr/local/apache-maven-3.1.1 -Dclassworlds.conf=/usr/local/apache-maven-3.1.1/bin/m2.conf -Didea.launcher.port=7533 -Didea.launcher.bin.path=/Applications/IntelliJ IDEA 15.app/Contents/bin -Dfile.encoding=UTF-8
10933 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home -Xms8m
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namejhatjhata&quot;&gt;&lt;a name=&quot;jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jhat 堆dump游览器 - 启动一个web服务在一个堆dump文件上（比如使用jmap -dump产生的&lt;br /&gt;文件），可以在界面来浏览堆数据。

jhat -h 帮助

jhat filename 分析dump文件
在上面我们使用了jmap -dump:live,format=b,file=test 7124
现在我们来浏览一下数据

→ jhat test
Reading from test...
Dump file created Sun Jul 31 18:20:41 CST 2016
Snapshot read, resolving...
Resolving 4317462 objects...
WARNING:  Failed to resolve object id 0x788fe2078 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f382a8 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f37f40 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f19328 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f191b0 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f18f90 for field clazz (signature L)
Chasing references, expect 863 dots..................................
Eliminating duplicate references..................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.

输出到这里说明已经ok了，那么接下来我们可以打开游览器，输入127.0.0.1:7000就可以浏览这些数据了
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jhat/jhat.png&quot; alt=&quot;jhat_输出&quot; /&gt;
游览器输出&lt;/p&gt;

&lt;h1 id=&quot;a-nametcyjmapa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jmap java内存图 根据指定的进程id或者核心文件或者远程debug server输出对象或者堆内存的情况

jmap 或者 jmap -help 输出使用帮助 

jmap -histo:7124 打印堆对象柱状图
下面是部分输出：num:编号 instance:实例数量 byte:大小 class-类名

 num     #instances         #bytes  class name
----------------------------------------------
   1:       2251207      406535312  [C
   2:        328187      263542800  [B
   3:         90692       51871032  [I
   4:       1922400       46137600  java.lang.String
   5:       1121773       35896736  java.util.HashMap$Entry
   6:        237870       32585432  &lt;constmethodklass&gt;
   7:        783437       31337480  java.util.HashMap$KeyIterator
   8:        237870       30457760  &lt;methodklass&gt;
   9:         21767       25312768  &lt;constantpoolklass&gt;
   
jmap -dump:&lt;dump-option&gt;

dump-option:
live  指定了该选择则只dump live object，所有就dump堆中所有对象。
format=b 二进制格式
file=&lt;file&gt; 指定dump的具体文件
比如:
jmap -dump:live,format=b,file=test 7124


&lt;/file&gt;&lt;/dump-option&gt;&lt;/constantpoolklass&gt;&lt;/methodklass&gt;&lt;/constmethodklass&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Java-mybatis generator返回主键的用法</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;用法介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;附：mybatis主键的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;用法介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;使用mybatis plugin,配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;install&amp;lt;/phase&amp;gt;
            &amp;lt;id&amp;gt;Generate MyBatis Artifacts&amp;lt;/id&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;configurationFile&amp;gt;src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
        &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;查看官方对于生成主键的配置的解释&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.mybatis.org/generator/configreference/generatedKey.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;generatorConfig.xml 配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nameckzlgeneratorconfiga&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code class=&quot;XML&quot;&gt;
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot; &amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;classPathEntry location=&amp;quot;/Users/lianghe/.m2/repository/mysql/mysql-connector-java/5.1.36/mysql-connector-java-5.1.36.jar&amp;quot;/&amp;gt;

    &amp;lt;context id=&amp;quot;mysql&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.EqualsHashCodePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.SerializablePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.ToStringPlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.RowBoundsPlugin&amp;quot;/&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot;/&amp;gt;

        &amp;lt;!-- &amp;#27880;&amp;#37322; --&amp;gt;
        &amp;lt;commentGenerator &amp;gt;
            &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#21462;&amp;#28040;&amp;#27880;&amp;#37322; --&amp;gt;
            &amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt; &amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#29983;&amp;#25104;&amp;#27880;&amp;#37322;&amp;#20195;&amp;#26102;&amp;#38388;&amp;#25139;--&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;

        &amp;lt;!-- jdbc --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
                        connectionURL=&amp;quot;jdbc:mysql://xx.xx.xx.xx/hotel_pda&amp;quot;
                        userId=&amp;quot;xxx&amp;quot;
                        password=&amp;quot;xxx&amp;quot; /&amp;gt;
        &amp;lt;!-- &amp;#29983;&amp;#25104;model --&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.xxx.domain&amp;quot;
                            targetProject=&amp;quot;src/main/java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;mapper/auto&amp;quot;
                         targetProject=&amp;quot;src/main/resources&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql client--&amp;gt;
        &amp;lt;javaClientGenerator targetPackage=&amp;quot;com.xxx.dao.auto&amp;quot;
                             targetProject=&amp;quot;src/main/java&amp;quot;
                             type=&amp;quot;XMLMAPPER&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;

        &amp;lt;!-- Tables --&amp;gt;
        &amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namexkdmybatisa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;附：mybatis返回主键的用法&lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;
&lt;code class=&quot;Java&quot;&gt;
public int insert(Domain domain) {
	//插入完成后 domain的主键id字段会被赋值，直接返回即可
	domainMapper.insertSelective(domain);
	return domain.getId();
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 04:09:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-lsof命令</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;lsof常用的一些命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;lsof（“list open files”）命令名称很容易记住，把它看成“ls + of”, 在linux下面，一切都是文件，lsof则可以查看这些文件。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://www.tecmint.com/10-lsof-command-examples-in-linux/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html?highlight=lsof&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkda&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;先了解输出吧&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们先运行一下lsof -R(加-R 可以打出ppid)命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -R
COMMAND     PID  PPID      USER   FD      TYPE             DEVICE SIZE/OFF      NODE NAME
init          1     0      root  cwd   unknown                                       /proc/1/cwd (readlink: Permission denied)
init          1     0      root  rtd   unknown                                       /proc/1/root (readlink: Permission denied)
init          1     0      root  txt   unknown                                       /proc/1/exe (readlink: Permission denied)
init          1     0      root NOFD                                                 /proc/1/fd (opendir: Permission denied)
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;COMMAND 进程名称&lt;/li&gt;
  &lt;li&gt;PID 进程id&lt;/li&gt;
  &lt;li&gt;PPID 进程父id&lt;/li&gt;
  &lt;li&gt;USER 进程所有者&lt;/li&gt;
  &lt;li&gt;FD 文件描述符
    &lt;pre&gt;
  &lt;code&gt;
  （1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
  （2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
  （3）lnn：library references (AIX);
  （4）er：FD information error (see NAME column);
  （5）jld：jail directory (FreeBSD);
  （6）ltx：shared library text (code and data);
  （7）mxx ：hex memory-mapped type number xx.
  （8）m86：DOS Merge mapped file;
  （9）mem：memory-mapped file;
  （10）mmap：memory-mapped device;
  （11）pd：parent directory;
  （12）rtd：root directory;
  （13）tr：kernel trace file (OpenBSD);
  （14）v86  VP/ix mapped file;
  （15）0：表示标准输出
  （16）1：表示标准输入
  （17）2：表示标准错误
  一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等
  （1）u：表示该文件被打开并处于读取/写入模式
  （2）r：表示该文件被打开并处于只读模式
  （3）w：表示该文件被打开并处于
  （4）空格：表示该文件的状态模式为unknow，且没有锁定
  （5）-：表示该文件的状态模式为unknow，且被锁定
  同时在文件状态模式后面，还跟着相关的锁
  （1）N：for a Solaris NFS lock of unknown type;
  （2）r：for read lock on part of the file;
  （3）R：for a read lock on the entire file;
  （4）w：for a write lock on part of the file;（文件的部分写锁）
  （5）W：for a write lock on the entire file;（整个文件的写锁）
  （6）u：for a read and write lock of any length;
  （7）U：for a lock of unknown type;
  （8）x：for an SCO OpenServer Xenix lock on part      of the file;
  （9）X：for an SCO OpenServer Xenix lock on the      entire file;
  （10）space：if there is no lock.
  &lt;/code&gt;
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;TYPE 文件类型
    &lt;pre&gt;
  &lt;code&gt;
  （1）DIR：表示目录
  （2）CHR：表示字符类型
  （3）BLK：块设备类型
  （4）UNIX： UNIX 域套接字
  （5）FIFO：先进先出 (FIFO) 队列
  （6）IPv4：网际协议 (IP) 套接字
  &lt;/code&gt;
  &lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;DEVICE 指定磁盘的名称&lt;/li&gt;
  &lt;li&gt;SIZE 文件大小&lt;/li&gt;
  &lt;li&gt;NODE 索引节点&lt;/li&gt;
  &lt;li&gt;NAME 打开文件的确切名称&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcylsofa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;lsof常用的一些命令&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定用户打开的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
lsof -u heliang05
COMMAND  PID      USER   FD      TYPE             DEVICE SIZE/OFF      NODE NAME
sshd    3126 heliang05  cwd   unknown                                       /proc/3126/cwd (readlink: Permission denied)
sshd    3126 heliang05  rtd   unknown                                       /proc/3126/root (readlink: Permission denied)
sshd    3126 heliang05  txt   unknown                                       /proc/3126/exe (readlink: Permission denied)
sshd    3126 heliang05 NOFD                                                 /proc/3126/fd (opendir: Permission denied)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;找到在特定TCP端口上运行的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i TCP:22
COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    1471    root    3u  IPv4  12683      0t0  TCP *:ssh (LISTEN)
sshd    1471    root    4u  IPv6  12685      0t0  TCP *:ssh (LISTEN)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;找到特定TCP端口范围上的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i TCP:0-1024
COMMAND    PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
Google     258 lianghe  153u  IPv4 0x8bc54911385f362b      0t0  TCP 172.30.30.61:57712-&amp;gt;10.32.255.116:http (ESTABLISHED)
Google     258 lianghe  156u  IPv4 0x8bc5491133dc4d23      0t0  TCP 172.30.30.61:57819-&amp;gt;103.37.152.63:https (CLOSE_WAIT)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的网络连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    6u  IPv4  11326      0t0  UDP *:sunrpc
rpcbind   1203     rpc    7u  IPv4  11330      0t0  UDP *:954
rpcbind   1203     rpc   11u  IPv6  11336      0t0  TCP *:sunrpc (LISTEN)
avahi-dae 1241   avahi   13u  IPv4  11579      0t0  UDP *:mdns
avahi-dae 1241   avahi   14u  IPv4  11580      0t0  UDP *:58600
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的ipv4连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i 4
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    6u  IPv4  11326      0t0  UDP *:sunrpc
rpcbind   1203     rpc    7u  IPv4  11330      0t0  UDP *:954
rpcbind   1203     rpc    8u  IPv4  11331      0t0  TCP *:sunrpc (LISTEN)
avahi-dae 1241   avahi   13u  IPv4  11579      0t0  UDP *:mdns
avahi-dae 1241   avahi   14u  IPv4  11580      0t0  UDP *:58600
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;查询所有的ipv6连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i 6
COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rpcbind   1203     rpc    9u  IPv6  11333      0t0  UDP *:sunrpc
rpcbind   1203     rpc   10u  IPv6  11335      0t0  UDP *:954
rpcbind   1203     rpc   11u  IPv6  11336      0t0  TCP *:sunrpc (LISTEN)
rpc.statd 1277 rpcuser   10u  IPv6  11858      0t0  UDP *:55800
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;根据指定的pid查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -p 1
COMMAND PID USER   FD   TYPE     DEVICE SIZE/OFF   NODE NAME
init      1 root  cwd    DIR      253,0     4096      2 /
init      1 root  rtd    DIR      253,0     4096      2 /
init      1 root  txt    REG      253,0   145180 147164 /sbin/init
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;列出谁在使用某个端口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# lsof -i :3306
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这些参数也可以互相组合使用&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jul 2016 04:20:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/21/Linux-lsof%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/21/Linux-lsof%E5%91%BD%E4%BB%A4/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-top命令</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;top常用的一些命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;top命令是Linux下常用的性能分析工具,特别是应用性能报警的时候，我们经常会用到这个命令&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://linuxaria.com/howto/understanding-the-top-command-on-linux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html?highlight=top&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdtopa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;先看懂top的输出吧&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们先运行一下top命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
top - 13:26:40 up 188 days, 20:28,  1 user,  load average: 0.07, 0.05, 0.05
Tasks: 145 total,   1 running, 144 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.7%us,  0.3%sy,  0.0%ni, 99.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   8059416k total,  7374232k used,   685184k free,   288420k buffers
Swap:  2096440k total,        0k used,  2096440k free,  5570192k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND     
 8182 sankuai   20   0  981m  40m 3420 S  3.0  0.5 180:24.71 sg_agent 
17939 sankuai   20   0 3612m 996m  17m S  1.7 12.7 639:16.22 java 
 8193 sankuai   20   0 1045m  29m 3152 S  1.3  0.4  84:28.97 sg_agent_worker   
10107 sankuai   20   0  268m 6724 3616 S  0.3  0.1   7:05.65 log_agent_file    
    1 root      20   0 23500 1552 1212 S  0.0  0.0   0:05.93 init 
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd 
    3 root      RT   0     0    0    0 S  0.0  0.0   0:54.01 migration/0       
    4 root      20   0     0    0    0 S  0.0  0.0   3:28.67 ksoftirqd/0       
    5 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;第一行内容-top
    &lt;ul&gt;
      &lt;li&gt;13:26:40 &lt;strong&gt;系统当前时间&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;188 days, 20:28, &lt;strong&gt;系统开机到现在经过了多少时间&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;1 user, &lt;strong&gt;当前1个用户在线&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;load average: 0.07, 0.05, 0.05 &lt;strong&gt;系统1分钟、5分钟、15分钟的CPU负载信息&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二行内容-task
    &lt;ul&gt;
      &lt;li&gt;Tasks &lt;strong&gt;任务,右边的数字也就是一个对任务的统计信息&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;145 total, &lt;strong&gt;任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;1 running, &lt;strong&gt;运行的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;144 sleeping, &lt;strong&gt;休眠的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;0 stopped, &lt;strong&gt;停止的任务总数&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;0 zombie, &lt;strong&gt;等待父进程来停止的任务总数&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第三行内容-cpu
    &lt;ul&gt;
      &lt;li&gt;0.7%us (&lt;em&gt;user processes&lt;/em&gt;)用户进程的CPU百分比,不包含renice值为负的任务。&lt;/li&gt;
      &lt;li&gt;0.3%sy (&lt;em&gt;system processes&lt;/em&gt;)系统进程的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%ni (processes with priority &lt;em&gt;upgrade nice&lt;/em&gt;)改变过优先级的进程的CPU百分比。&lt;/li&gt;
      &lt;li&gt;99.0%id 没被利用的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%wa (processes &lt;em&gt;waiting&lt;/em&gt; for I/O operations)等待I/O的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%hi (&lt;em&gt;hardware interrupts&lt;/em&gt;)硬中断的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%si (&lt;em&gt;software interrupts&lt;/em&gt;)软终端的CPU百分比。&lt;/li&gt;
      &lt;li&gt;0.0%st (&lt;em&gt;Steal Time&lt;/em&gt;)通常我们服务器是一个虚拟机，这个指标就代表宿主机上其他虚拟机实例偷取的CPU时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第四行内容-内存利用
    &lt;ul&gt;
      &lt;li&gt;8059416k total, 物理内存总量&lt;/li&gt;
      &lt;li&gt;7374232k used, 使用的物理内存量&lt;/li&gt;
      &lt;li&gt;685184k free, 空闲的物理内存量&lt;/li&gt;
      &lt;li&gt;288420k buffers, 用作内核缓存的物理内存量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第五行内容-交换空间
    &lt;ul&gt;
      &lt;li&gt;2096440k total, 交换区总量&lt;/li&gt;
      &lt;li&gt;0k used, 使用的交换区量&lt;/li&gt;
      &lt;li&gt;2096440k free, 空闲的交换区量&lt;/li&gt;
      &lt;li&gt;5570192k cached, 缓冲交换区总量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;大于第六行内容-进程列表
    &lt;ul&gt;
      &lt;li&gt;PID：进程的ID&lt;/li&gt;
      &lt;li&gt;USER：进程所有者&lt;/li&gt;
      &lt;li&gt;PR：进程的优先级别，越小越优先被执行&lt;/li&gt;
      &lt;li&gt;NI：The “NICE” value of the process，&lt;a href=&quot;#niv&quot;&gt;关于nice value of process的解释&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;VIRT：进程占用的虚拟内存&lt;/li&gt;
      &lt;li&gt;RES：进程占用的物理内存&lt;/li&gt;
      &lt;li&gt;SHR：进程使用的共享内存&lt;/li&gt;
      &lt;li&gt;S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数&lt;/li&gt;
      &lt;li&gt;%CPU：进程占用CPU的使用率&lt;/li&gt;
      &lt;li&gt;%MEM：进程使用的物理内存和总内存的百分比&lt;/li&gt;
      &lt;li&gt;TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。&lt;/li&gt;
      &lt;li&gt;COMMAND：进程启动命令名称&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcytopa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;top常用的一些命令&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;命令行命令
    &lt;ul&gt;
      &lt;li&gt;a 根据内存利用率排序&lt;/li&gt;
      &lt;li&gt;b 在“批量模式”启动top,这种模式很利于把输出top的结果，这种模式下，top不再接受你输入的&lt;strong&gt;界面命令&lt;/strong&gt;，同时它会运行至 -n 命令设置的时间或者手动kill掉&lt;/li&gt;
      &lt;li&gt;H 线程开关（这个经常用于排查故障，找出有问题的线程pid），使用这个命令会把进程私有的线程也都输出出来。&lt;/li&gt;
      &lt;li&gt;n 用法 -n (number)，top每隔一段时间就会输出一次，这个-n就是指定top输出的次数&lt;/li&gt;
      &lt;li&gt;p 指定pid输出对应的进程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;界面命令 （输入top之后可以输入的命令）
    &lt;ul&gt;
      &lt;li&gt;q 退出&lt;/li&gt;
      &lt;li&gt;space 立即刷新&lt;/li&gt;
      &lt;li&gt;s 设置刷新时间&lt;/li&gt;
      &lt;li&gt;c COMMAND 显示完整的命令 等效于 top -c&lt;/li&gt;
      &lt;li&gt;k kill 进程&lt;/li&gt;
      &lt;li&gt;u 指定用户&lt;/li&gt;
      &lt;li&gt;t 显示或隐藏进程和CPU状态信息&lt;/li&gt;
      &lt;li&gt;m 显示或隐藏内存状态信息&lt;/li&gt;
      &lt;li&gt;l 显示或隐藏uptime信息&lt;/li&gt;
      &lt;li&gt;1 监控每个逻辑CPU的状况&lt;/li&gt;
      &lt;li&gt;P 按%CPU使用率排行&lt;/li&gt;
      &lt;li&gt;T 按MITE+排行&lt;/li&gt;
      &lt;li&gt;M 按%MEM排行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他命令请使用 man top&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namenivnice-value-of-processa&quot;&gt;&lt;a name=&quot;niv&quot;&gt;nice value of process&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;http://askubuntu.com/questions/399357/what-does-the-nice-value-mean-in-cpu-utilization-statistics&lt;/p&gt;

&lt;p&gt;The nice value for the processor is&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the time the CPU has spent running users’ processes that have been “niced”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(from man top) A “niced” process is one with a positive nice value. So if the processor’s nice value is high, that means it is working with some low priority processes. So this indicator is useful when you see high CPU utilization and you are afraid that this high load will have bad effect on your system:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;High CPU utilization with high nice value: Nothing to worry, not so important tasks doing their job, important processes will easily get CPU time if they need. This situation is not a real bottleneck.&lt;/li&gt;
  &lt;li&gt;High CPU utilization with low nice value: Something to worry because the CPU is stressed with important processes so these or new processes will have to wait. This situation is a real bottleneck.
I think this nice value is not too important for a simple user, this is more useful in a server environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：nice value值越高的时候，被cpu执行的机会越少，如果进程占用cpu比较高，同时nice value也比较高的话，你就需要担心了。说明此时cpu比较紧张&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Jun 2016 21:18:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/06/20/Linux-Top%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/06/20/Linux-Top%E5%91%BD%E4%BB%A4/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>linux下文件查看技巧</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bj&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aml&quot;&gt;awk命令&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#qb&quot;&gt;起步&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nzbl&quot;&gt;内置变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#zfcpp&quot;&gt;字符串的匹配&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cfwj&quot;&gt;拆分文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tj&quot;&gt;统计&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dybg&quot;&gt;打印表格&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hjbl&quot;&gt;环境变量&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namebja&quot;&gt;&lt;a name=&quot;bj&quot;&gt;背景&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在工作中我们经常需要查看日志来迅速的定位问题,同时发生故障时我们要经常的统计日志中相关的内容，那么掌握一些常用的日志操作命令就非常必要了。&lt;/p&gt;

&lt;p&gt;之前了解了常用的几个统计读取日志的命令以及正则表达式,这节了解一下非常强大的两个命令,一个是sed,一个是awk,这两个命令能够完成绝大部分的关键词的取用和统计。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://coolshell.cn/articles/9070.html#more-9070&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大量的例子都是从这里搬运的，推荐大家看酷壳，个人觉得帮助到我很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-nameamlawka&quot;&gt;&lt;a name=&quot;aml&quot;&gt;awk命令&lt;/a&gt;&lt;/h1&gt;

&lt;h3 id=&quot;a-nameqba&quot;&gt;&lt;a name=&quot;qb&quot;&gt;起步&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;功能：管道流编辑器,它可以读指定的文件或者标准输入流,通过一系列的命名可以去修改读到的输入,然后再将修改后的输入进行输出。它可以对匹配的每行都进行处理，比如同时加上什么东西，替换什么东西，减少什么东西。&lt;br /&gt;
直接看例子：&lt;br /&gt;
测试文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ cat test
1-2-3-4-5
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取出部分字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;{print $1 &quot; lalala &quot; $4}&#39; test 
1 lalala 4
2 lalala 4
3 lalala 4
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面加上判断条件&lt;br /&gt;
&lt;strong&gt;其中的“==”为比较运算符。其他比较运算符：!=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1==2 || $1==3 {print $1 &quot; lalala &quot; $4}&#39; test 
2 lalala 4
3 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来一个吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 {print $1 &quot; lalala &quot; $4}&#39; test 
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namenzbla&quot;&gt;&lt;a name=&quot;nzbl&quot;&gt;内置变量&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们可以来了解一下awk的一些内建变量,然后直接来使用看看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$0	当前记录（这个变量中存放着整个行的内容）
$1~$n	当前记录的第n个字段，字段间由FS分隔
FS	输入字段分隔符 默认是空格或Tab
NF	当前记录中的字段个数，就是有多少列
NR	已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。
FNR	当前记录数，与NR不同的是，这个值会是各个文件自己的行号
RS	输入的记录分隔符， 默认为换行符
OFS	输出字段分隔符， 默认也是空格
ORS	输出的记录分隔符，默认为换行符
FILENAME	当前输入文件的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试NR，把第一行打出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 || NR==1 {print $1 &quot; lalala &quot; $4}&#39; test
1 lalala 4
4 lalala 4
5 lalala 4
6 lalala 4
7 lalala 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;BEGIN{FS=&quot;:&quot;} {print $1 &quot; lalala &quot; $4}&#39; test
等价于
→ awk -F &quot;-&quot; &#39;{print $1 &quot; lalala &quot; $4}&#39; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你要指定多个分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &#39;[;:]&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OFS的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1&amp;gt;3 || NR==1 {print $1,$2,$3}&#39; OFS=&quot;输出记录分隔符&quot; test 
1输出记录分隔符2输出记录分隔符3
4输出记录分隔符2输出记录分隔符3
5输出记录分隔符2输出记录分隔符3
6输出记录分隔符2输出记录分隔符3
7输出记录分隔符2输出记录分隔符3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namezfcppa&quot;&gt;&lt;a name=&quot;zfcpp&quot;&gt;字符串匹配&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;匹配第一列有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1 ~ /1/ &#39; test 
1-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配第一列没有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F &quot;-&quot; &#39;$1 !~ /1/ &#39; test 
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配这一行有1的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;/1/&#39; test  
1-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配这一行没有1的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk &#39;!/1/&#39; test 
2-2-3-4-5
3-2-3-4-5
4-2-3-4-5
5-2-3-4-5
6-2-3-4-5
7-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namecfwja&quot;&gt;&lt;a name=&quot;cfwj&quot;&gt;拆分文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;匹配第一列有1的这一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F&quot;-&quot; &#39;{print &amp;gt; $1}&#39; test

→ ll
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 1
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 2
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 3
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 4
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 5
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 6
-rw-r--r--   1 lianghe  staff         10  6 16 12:20 7

→ cat 1
1-2-3-4-5

→ cat 2
2-2-3-4-5

→ cat 3
3-2-3-4-5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以把指定的列输出到文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
→ awk -F&quot;-&quot; &#39;{print $1,$2 &amp;gt; $1}&#39; test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-nametja&quot;&gt;&lt;a name=&quot;tj&quot;&gt;统计&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ ls -l  *.cpp *.c *.h | awk &#39;{sum+=$5} END {print sum}&#39;
2511401
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namedybga&quot;&gt;&lt;a name=&quot;dybg&quot;&gt;打印表格&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：&lt;/p&gt;

&lt;p&gt;BEGIN{ 这里面放的是执行前的语句 }
END {这里面放的是处理完所有的行后要执行的语句 }
{这里面放的是处理每一行时要执行的语句}
为了说清楚这个事，我们来看看下面的示例：&lt;/p&gt;

&lt;p&gt;假设有这么一个文件（学生成绩表）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0
 
    printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;
    printf &quot;---------------------------------------------\n&quot;
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf &quot;---------------------------------------------\n&quot;
    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer
    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-namehjbla&quot;&gt;&lt;a name=&quot;hjbl&quot;&gt;环境变量&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ x=5
 
$ y=10
$ export y
 
$ echo $x $y
5 10
 
$ awk -v val=$x &#39;{print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]}&#39; OFS=&quot;\t&quot; score.txt
Marry   2143    78      89      87
Jack    2321    66      83      55
Tom     2122    48      82      81
Mike    2537    87      102     105
Bob     2415    40      62      72
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 17 May 2016 01:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A74/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/05/17/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A74/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
  </channel>
</rss>
