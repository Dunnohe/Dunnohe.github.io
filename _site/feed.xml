<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io/</link>
    <atom:link href="http://dunnohe.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 24 Aug 2016 10:19:08 +0800</pubDate>
    <lastBuildDate>Wed, 24 Aug 2016 10:19:08 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在大多数使用spring的项目场景来说，都是web项目。那我们先从入口开始学习，了解spring是如何启动的。&lt;/p&gt;
&lt;p&gt;我这里学习的spring4的代码，和spring3的有些出入。可以checkout 4.x版本观看&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/ 7.15.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namedmlja&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;application&quot;&gt;注册Application&lt;/h2&gt;

&lt;p&gt;首先web 项目应用是通过ContextLoaderListener来注册Applicationcontext的。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;

&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;contextloaderlistener&quot;&gt;ContextLoaderListener代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
	public ContextLoaderListener() {
	}

	public ContextLoaderListener(WebApplicationContext context) {
		super(context);
	}

	@Override
	public void contextInitialized(ServletContextEvent event) {
		//初始化根上下文信息
		initWebApplicationContext(event.getServletContext());
	}

	@Override
	public void contextDestroyed(ServletContextEvent event) {
		//关闭根上下文信息
		closeWebApplicationContext(event.getServletContext());
		//清除初始化过程中种下的一些属性
		ContextCleanupListener.cleanupAttributes(event.getServletContext());
	}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ioc&quot;&gt;具体初始化IOC容器代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
		
		//判断是否已经种下了根上下文，没有就抛出异常
		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
			throw new IllegalStateException(
					&quot;Cannot initialize context because there is already a root application context present - &quot; +
					&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
		}

		Log logger = LogFactory.getLog(ContextLoader.class);
		servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
		if (logger.isInfoEnabled()) {
			logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
			
			//创建上下文信息
			if (this.context == null) {
				//该方法逻辑：这里不贴具体代码了，太多了
				//1，从servletcontext上下文中拿到对应初始化参数
				//2，生成实例类
				//3，确保该实例类来源于ConfigurableWebApplicationContext,否则抛出异常
				//4，将这个类转成webapplicationcontext并且返回出去
				this.context = createWebApplicationContext(servletContext);
			}

			//确保上下文信息来源了ConfigurableWebApplicationContext
			if (this.context instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
				if (!cwac.isActive()) {
					// The context has not yet been refreshed -&amp;gt; provide services such as
					// setting the parent context, setting the application context id, etc
					if (cwac.getParent() == null) {
						// The context instance was injected without an explicit parent -&amp;gt;
						// determine parent for root web application context, if any.
						//获得双亲上下文，并且设置进来
						ApplicationContext parent = loadParentContext(servletContext);
						cwac.setParent(parent);
					}

					//逻辑：这里不贴具体代码了，太多了
					//1，里面设置了webApplicationContext的相关属性
					//2，调用webapplicationContext的refresh方法，refresh方法就是启动容器的方法
					configureAndRefreshWebApplicationContext(cwac, servletContext);
				}
			}

			//种下上下文信息
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);


			ClassLoader ccl = Thread.currentThread().getContextClassLoader();
			if (ccl == ContextLoader.class.getClassLoader()) {
				currentContext = this.context;
			}
			else if (ccl != null) {
				currentContextPerThread.put(ccl, this.context);
			}

			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
			}
			if (logger.isInfoEnabled()) {
				long elapsedTime = System.currentTimeMillis() - startTime;
				logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
			}

			return this.context;
		}
		catch (RuntimeException ex) {
			logger.error(&quot;Context initialization failed&quot;, ex);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
			throw ex;
		}
		catch (Error err) {
			logger.error(&quot;Context initialization failed&quot;, err);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
			throw err;
		}
	}
}

&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Mon, 22 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A63%E4%BA%86%E8%A7%A3IOC%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A63%E4%BA%86%E8%A7%A3IOC%E5%AE%B9%E5%99%A8/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在大多数使用spring的项目场景来说，都是web项目。那我们先从入口开始学习，了解spring是如何启动的。&lt;/p&gt;
&lt;p&gt;我这里学习的spring4的代码，和spring3的有些出入。可以checkout 4.x版本观看&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/ 7.15.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namedmlja&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;application&quot;&gt;注册Application&lt;/h2&gt;

&lt;p&gt;首先web 项目应用是通过ContextLoaderListener来注册Applicationcontext的。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;

&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;contextloaderlistener&quot;&gt;ContextLoaderListener代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
	public ContextLoaderListener() {
	}

	public ContextLoaderListener(WebApplicationContext context) {
		super(context);
	}

	@Override
	public void contextInitialized(ServletContextEvent event) {
		//初始化根上下文信息
		initWebApplicationContext(event.getServletContext());
	}

	@Override
	public void contextDestroyed(ServletContextEvent event) {
		//关闭根上下文信息
		closeWebApplicationContext(event.getServletContext());
		//清除初始化过程中种下的一些属性
		ContextCleanupListener.cleanupAttributes(event.getServletContext());
	}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ioc&quot;&gt;具体初始化IOC容器代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
		
		//判断是否已经种下了根上下文，没有就抛出异常
		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
			throw new IllegalStateException(
					&quot;Cannot initialize context because there is already a root application context present - &quot; +
					&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
		}

		Log logger = LogFactory.getLog(ContextLoader.class);
		servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
		if (logger.isInfoEnabled()) {
			logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
			
			//创建上下文信息
			if (this.context == null) {
				//该方法逻辑：这里不贴具体代码了，太多了
				//1，从servletcontext上下文中拿到对应初始化参数
				//2，生成实例类
				//3，确保该实例类来源于ConfigurableWebApplicationContext,否则抛出异常
				//4，将这个类转成webapplicationcontext并且返回出去
				this.context = createWebApplicationContext(servletContext);
			}

			//确保上下文信息来源了ConfigurableWebApplicationContext
			if (this.context instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
				if (!cwac.isActive()) {
					// The context has not yet been refreshed -&amp;gt; provide services such as
					// setting the parent context, setting the application context id, etc
					if (cwac.getParent() == null) {
						// The context instance was injected without an explicit parent -&amp;gt;
						// determine parent for root web application context, if any.
						//获得双亲上下文，并且设置进来
						ApplicationContext parent = loadParentContext(servletContext);
						cwac.setParent(parent);
					}

					//逻辑：这里不贴具体代码了，太多了
					//1，里面设置了webApplicationContext的相关属性
					//2，调用webapplicationContext的refresh方法，refresh方法就是启动容器的方法
					configureAndRefreshWebApplicationContext(cwac, servletContext);
				}
			}

			//种下上下文信息
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);


			ClassLoader ccl = Thread.currentThread().getContextClassLoader();
			if (ccl == ContextLoader.class.getClassLoader()) {
				currentContext = this.context;
			}
			else if (ccl != null) {
				currentContextPerThread.put(ccl, this.context);
			}

			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
			}
			if (logger.isInfoEnabled()) {
				long elapsedTime = System.currentTimeMillis() - startTime;
				logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
			}

			return this.context;
		}
		catch (RuntimeException ex) {
			logger.error(&quot;Context initialization failed&quot;, ex);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
			throw ex;
		}
		catch (Error err) {
			logger.error(&quot;Context initialization failed&quot;, err);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
			throw err;
		}
	}
}

&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Mon, 22 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A62%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A62%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;下载源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前一直停留在应用的阶段，了解的部分也不够全面，这次希望能对spring项目有一个全面的了解。&lt;/p&gt;
&lt;p&gt;spring的项目搭建起来很方便，由于spring依赖gradle,但是你不用事先去下，因为项目下下来之后里面有一键安装的脚本。但是spring4依赖jdk8，如果你想研究spring4的源码，需要事先安装好，我这里介绍的是搭建spring3的，但是后来我还是决定学习spring4的代码，搭建方法是一样的。不影响。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;下载源码&lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;
&lt;code&gt;
git clone git@github.com:spring-projects/spring-framework.git
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namexkda&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;下下来默认是spring4,spring4默认依赖jdk8,（如果你没有jdk8的话）你用里面脚本安装的时候会通不过，因为JVM参数不支持。
你可以选择切换的低版本的分支，或者安装JDK8，我这里选择切换分支。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;查看远程分支&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/showbranch.png&quot; alt=&quot;查看远程分支&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;切换分支&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/switchbranch.png&quot; alt=&quot;切换远程分支&quot; /&gt;&lt;/p&gt;
&lt;p&gt;你会看到这样的目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/list.png&quot; alt=&quot;切换远程分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好，由于我的IDE环境使用的是idea，我们看下import-into-idea.md里面的介绍。eclipse的项目看对应介绍，步骤几乎一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/readme.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好，步骤很清楚了，我们先来执行第一步：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
./gradlew :spring-oxm:compileTestJava cleanIdea idea
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这一步执行起来比较久，得1个多小时，我们慢慢等...&lt;/p&gt;
&lt;p&gt;执行完成，我们open项目&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/import.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择build.gradle&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/build.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击ok&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/ok.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击 open existing project&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/exist.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/16/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A61%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/16/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A61%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍4</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这一次总结的命令是**jinfo**，实际这个命令并不复杂，用的也不多，专门拿一个篇幅总结是想借着这个命令同时总结一下JVM常用的参数&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#Options&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjinfoa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jinfo命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
Usage:
    jinfo [option] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jinfo [option] &amp;lt;executable &amp;lt;core&amp;gt;
        (to connect to a core file)
    jinfo [option] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to remote debug server)

where &amp;lt;option&amp;gt; is one of:
    -flag &amp;lt;name&amp;gt;         输出指定JVM参数的值
    -flag [+|-]&amp;lt;name&amp;gt;    启动或者禁用JVM的参数
    -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; 设置JVM参数的值
    -flags               输出所有jvm参数的值
    -sysprops            输出系统属性
    &amp;lt;no option&amp;gt;    输出上面两个属性说有结果
    -h | -help           输出使用用法
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;jinfo--flags-10536&quot;&gt;示例: jinfo -flags 10536&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
部分输出...

Attaching to process ID 10536, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.76-b04

-Dapp.key=hotel.HotelCampaignsWeb -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 
-Djava.io.tmpdir=/tmp -Djava.net.preferIPv6Addresses=false -Xdebug -Xnoagent
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjvm-optionsa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;behavioral-options&quot;&gt;Behavioral Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-AllowUserSignalHandlers&lt;/td&gt;
        &lt;td&gt;Do not complain if the application installs signal handlers. (Relevant to Solaris and Linux only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AltStackSize=16384&lt;/td&gt;
        &lt;td&gt;Alternate signal stack size (in Kbytes). (Relevant to Solaris only, removed from 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-DisableExplicitGC&lt;/td&gt;
        &lt;td&gt;By default calls to System.gc() are enabled (-XX:-DisableExplicitGC). Use -XX:+DisableExplicitGC to disable
            calls to System.gc(). Note that the JVM still performs garbage collection when necessary.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+FailOverToOldVerifier&lt;/td&gt;
        &lt;td&gt;Fail over to old verifier when the new type checker fails. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+HandlePromotionFailure&lt;/td&gt;
        &lt;td&gt;The youngest generation collection does not require a guarantee of full promotion of all live objects.
            (Introduced in 1.4.2 update 11) [5.0 and earlier: false.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+MaxFDLimit&lt;/td&gt;
        &lt;td&gt;Bump the number of file descriptors to max. (Relevant&amp;nbsp; to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:PreBlockSpin=10&lt;/td&gt;
        &lt;td&gt;Spin count variable for use with -XX:+UseSpinning. Controls the maximum spin iterations allowed before
            entering operating system thread synchronization code. (Introduced in 1.4.2.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-RelaxAccessControlCheck&lt;/td&gt;
        &lt;td&gt;Relax the access control checks in the verifier. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+ScavengeBeforeFullGC&lt;/td&gt;
        &lt;td&gt;Do young generation GC prior to a full GC. (Introduced in 1.4.1.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseAltSigs&lt;/td&gt;
        &lt;td&gt;Use alternate signals instead of SIGUSR1 and SIGUSR2 for VM internal signals. (Introduced in 1.3.1 update 9,
            1.4.1. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBoundThreads&lt;/td&gt;
        &lt;td&gt;Bind user level threads to kernel threads. (Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseConcMarkSweepGC&lt;/td&gt;
        &lt;td&gt;Use concurrent mark-sweep collection for the old generation. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseGCOverheadLimit&lt;/td&gt;
        &lt;td&gt;Use a policy that limits the proportion of the VM&#39;s time that is spent in GC before an OutOfMemory error is
            thrown. (Introduced in 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLWPSynchronization&lt;/td&gt;
        &lt;td&gt;Use LWP-based instead of thread based synchronization. (Introduced in 1.4.0. Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for scavenges. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelOldGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for the full collections. Enabling this option automatically sets
            -XX:+UseParallelGC. (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSerialGC&lt;/td&gt;
        &lt;td&gt;Use serial garbage collection. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSpinning&lt;/td&gt;
        &lt;td&gt;Enable naive spinning on Java monitor before entering operating system thread synchronizaton code. (Relevant
            to 1.4.2 and 5.0 only.) [1.4.2, multi-processor Windows platforms: true]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseTLAB&lt;/td&gt;
        &lt;td&gt;Use thread-local object allocation (Introduced in 1.4.0, known as UseTLE prior to that.) [1.4.2 and earlier,
            x86 or with -client: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseSplitVerifier&lt;/td&gt;
        &lt;td&gt;Use the new type checker with StackMapTable attributes. (Introduced in 5.0.)[5.0: false]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseThreadPriorities&lt;/td&gt;
        &lt;td&gt;Use native thread priorities.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseVMInterruptibleIO&lt;/td&gt;
        &lt;td&gt;Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. (Introduced in 6. Relevant to
            Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;garbage-first-g1-garbage-collection-options&quot;&gt;Garbage First (G1) Garbage Collection Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseG1GC&lt;/td&gt;
        &lt;td&gt;Use the Garbage First (G1) Collector&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxGCPauseMillis=n&lt;/td&gt;
        &lt;td&gt;Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to
            achieve it.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitiatingHeapOccupancyPercent&lt;span id=&quot;MainContent&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a
            concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A
            value of 0 denotes &#39;do constant GC cycles&#39;. The default value is 45.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. The default value is 2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size. The default value is 8.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Maximum value for tenuring threshold. The default value is 15.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of threads used during parallel phases of the garbage collectors. The default value varies
            with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ConcGCThreads=n&lt;/td&gt;
        &lt;td&gt;Number of threads concurrent garbage collectors will use. The default value varies with the platform on
            which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1ReservePercent&lt;span id=&quot;MainContent2&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure.
            The default value is 10.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1HeapRegionSize&lt;span id=&quot;MainContent3&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual
            sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The
            minimum value is 1Mb and the maximum value is 32Mb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;performance-options&quot;&gt;Performance Options&lt;/h2&gt;
&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AggressiveOpts&lt;/td&gt;
        &lt;td&gt;Turn on point performance compiler optimizations that are expected to be default in upcoming releases.
            (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:CompileThreshold=10000&lt;/td&gt;
        &lt;td&gt;Number of method invocations/branches before compiling [-client: 1,500]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LargePageSizeInBytes=4m&lt;/td&gt;
        &lt;td&gt;Sets the large page size used for the Java heap. (Introduced in 1.4.0 update 1.) [amd64: 2m.]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxHeapFreeRatio=70&lt;/td&gt;
        &lt;td&gt;Maximum percentage of heap free after GC to avoid shrinking.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxNewSize=size&lt;/td&gt;
        &lt;td&gt;Maximum size of new generation (in bytes). Since 1.4, MaxNewSize is computed as a function of NewRatio.
            [1.3.1 Sparc: 32m; 1.3.1 x86: 2.5m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxPermSize=64m&lt;/td&gt;
        &lt;td&gt;Size of the Permanent Generation.&amp;nbsp; [5.0 and newer: 64 bit VMs are scaled 30% larger; 1.4 amd64: 96m;
            1.3.1 -client: 32m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MinHeapFreeRatio=40&lt;/td&gt;
        &lt;td&gt;Minimum percentage of heap free after GC to avoid expansion.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=2&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. [Sparc -client: 8; x86 -server: 8; x86 -client: 12.]-client: 4 (1.3) 8
            (1.3.1+), x86: 12]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewSize=2m&lt;/td&gt;
        &lt;td&gt;Default size of new generation (in bytes) [5.0 and newer: 64 bit VMs are scaled 30% larger; x86: 1m; x86,
            5.0 and older: 640k]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ReservedCodeCacheSize=32m&lt;/td&gt;
        &lt;td&gt;Reserved code cache size (in bytes) - maximum code cache size. [Solaris 64-bit, amd64, and -server x86:
            2048m; in 1.5.0_06 and earlier, Solaris 64-bit and amd64: 1024m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=8&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size [Solaris amd64: 6; Sparc in 1.3.1: 25; other Solaris platforms in 5.0 and
            earlier: 32]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:TargetSurvivorRatio=50&lt;/td&gt;
        &lt;td&gt;Desired percentage of survivor space used after scavenge.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ThreadStackSize=512&lt;/td&gt;
        &lt;td&gt;Thread Stack Size (in Kbytes). (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior
            in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBiasedLocking&lt;/td&gt;
        &lt;td&gt;Enable biased locking. For more details, see this &lt;a href=&quot;/technetwork/java/tuning-139912.html#section4.2.5&quot;&gt;tuning example&lt;/a&gt;. (Introduced in 5.0 update
            6.) [5.0: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
        &lt;td&gt;Use optimized versions of Get&amp;lt;Primitive&amp;gt;Field.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseISM&lt;/td&gt;
        &lt;td&gt;Use Intimate Shared Memory. [Not accepted for non-Solaris platforms.] For details, see &lt;a href=&quot;/technetwork/java/ism-139376.html&quot;&gt;Intimate Shared Memory&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLargePages&lt;/td&gt;
        &lt;td&gt;Use large page memory. (Introduced in 5.0 update 5.) For details, see &lt;a href=&quot;/technetwork/java/javase/tech/largememory-jsp-137182.html&quot;&gt;Java Support for Large Memory Pages&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseMPSS&lt;/td&gt;
        &lt;td&gt;Use Multiple Page Size Support w/4mb pages for the heap. Do not use with ISM as this replaces the need for
            ISM. (Introduced in 1.4.0 update 1, Relevant to Solaris 9 and newer.) [1.4.1 and earlier: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseStringCache&lt;/td&gt;
        &lt;td&gt;Enables caching of commonly allocated strings.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchLines=1&lt;/td&gt;
        &lt;td&gt;Number of cache lines to load after the last object allocation using prefetch instructions generated in JIT
            compiled code. Default values are 1 if the last allocated object was an instance and 3 if it was an array.
            &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchStyle=1&lt;/td&gt;
        &lt;td&gt;Generated code style for prefetch instructions.&lt;br /&gt; 0 - no prefetch instructions are generate*d*,&lt;br /&gt; 1 -
            execute prefetch instructions after each allocation,&lt;br /&gt; 2 - use TLAB allocation watermark pointer to gate
            when prefetch instructions are executed.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedStrings&lt;/td&gt;
        &lt;td&gt;Use a byte[] for Strings which can be represented as pure ASCII. (Introduced in Java 6 Update 21 Performance
            Release) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
        &lt;td&gt;Optimize String concatenation operations where possible. (Introduced in Java 6 Update 20) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;debugging-options&quot;&gt;Debugging Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-CITime&lt;/td&gt;
        &lt;td&gt;Prints time spent in JIT Compiler. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ErrorFile=./hs_err_pid&amp;lt;pid&amp;gt;.log&lt;/td&gt;
        &lt;td&gt;If an error occurs, save the error data to this file. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-ExtendedDTraceProbes&lt;/td&gt;
        &lt;td&gt;Enable performance-impacting &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/vm/dtrace.html&quot;&gt;dtrace&lt;/a&gt;
            probes. (Introduced in 6. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:HeapDumpPath=./java_pid&amp;lt;pid&amp;gt;.hprof&lt;/td&gt;
        &lt;td&gt;Path to directory or filename for heap dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2 update 12, 5.0 update
            7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-HeapDumpOnOutOfMemoryError&lt;/td&gt;
        &lt;td&gt;Dump heap to file when java.lang.OutOfMemoryError is thrown. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2
            update 12, 5.0 update 7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnError=&quot;&amp;lt;cmd args&amp;gt;;&amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands on fatal error. (Introduced in 1.4.2 update 9.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnOutOfMemoryError=&quot;&amp;lt;cmd args&amp;gt;; &lt;br clear=&quot;none&quot; /&gt; &amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands when an OutOfMemoryError is first thrown. (Introduced in 1.4.2 update 12, 6)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintClassHistogram&lt;/td&gt;
        &lt;td&gt;Print a histogram of class instances on Ctrl-Break. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html&quot;&gt;jmap -histo&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintConcurrentLocks&lt;/td&gt;
        &lt;td&gt;Print java.util.concurrent locks in Ctrl-Break thread dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 6.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstack.html&quot;&gt;jstack -l&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCommandLineFlags&lt;/td&gt;
        &lt;td&gt;Print flags that appeared on the command line. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCompilation&lt;/td&gt;
        &lt;td&gt;Print message when a method is compiled.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGC&lt;/td&gt;
        &lt;td&gt;Print messages at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCDetails&lt;/td&gt;
        &lt;td&gt;Print more details at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCTimeStamps&lt;/td&gt;
        &lt;td&gt;Print timestamps at garbage collection. &lt;em&gt;Manageable&lt;/em&gt; (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintTenuringDistribution&lt;/td&gt;
        &lt;td&gt;Print tenuring age information.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintAdaptiveSizePolicy&lt;/td&gt;
        &lt;td&gt;Enables printing of information about adaptive generation sizing.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoading&lt;/td&gt;
        &lt;td&gt;Trace loading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoadingPreorder&lt;/td&gt;
        &lt;td&gt;Trace all classes loaded in order referenced (not loaded). (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassResolution&lt;/td&gt;
        &lt;td&gt;Trace constant pool resolutions. (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassUnloading&lt;/td&gt;
        &lt;td&gt;Trace unloading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceLoaderConstraints&lt;/td&gt;
        &lt;td&gt;Trace recording of loader constraints. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+PerfDataSaveToFile&lt;/td&gt;
        &lt;td&gt;Saves jvmstat binary data on exit.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of garbage collection threads in the young and old parallel garbage collectors. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedOops&lt;/td&gt;
        &lt;td&gt;Enables the use of compressed pointers (object references represented as 32 bit offsets instead of 64-bit
            pointers) for optimized 64-bit performance with Java heap sizes less than 32gb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
        &lt;td&gt;Pre-touch the Java heap during JVM initialization. Every page of the heap is thus demand-zeroed during
            initialization rather than incrementally during application execution.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchDistance=n&lt;/td&gt;
        &lt;td&gt;Sets the prefetch distance for object allocation. Memory about to be written with the value of new objects
            is prefetched into cache at this distance (in bytes) beyond the address of the last allocated object. Each
            Java thread has its own allocation point. The default value varies with the platform on which the JVM is
            running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InlineSmallCode=n&lt;/td&gt;
        &lt;td&gt;Inline a previously compiled method only if its generated native code size is less than this. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxInlineSize=35&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a method to be inlined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:FreqInlineSize=n&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a frequently executed method to be inlined. The default value varies with the
            platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LoopUnrollLimit=n&lt;/td&gt;
        &lt;td&gt;Unroll loop bodies with server compiler intermediate representation node count less than this value. The
            limit used by the server compiler is a function of this value, not the actual value. The default value
            varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitialTenuringThreshold=7&lt;/td&gt;
        &lt;td&gt;Sets the initial tenuring threshold for use in adaptive GC sizing in the parallel young collector. The
            tenuring threshold is the number of times an object survives a young collection before being promoted to the
            old, or tenured, generation.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Sets the maximum tenuring threshold for use in adaptive GC sizing. The current largest value is 15. The
            default value is 15 for the parallel collector and is 4 for CMS.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-Xloggc:&amp;lt;filename&amp;gt;&lt;/td&gt;
        &lt;td&gt;Log GC verbose output to specified file. The verbose output is controlled by the normal verbose GC flags.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseGCLogFileRotation&lt;/td&gt;
        &lt;td&gt;Enabled GC log rotation, requires -Xloggc.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NumberOfGClogFiles=1&lt;/td&gt;
        &lt;td&gt;Set the number of files to use when rotating logs, must be &amp;gt;= 1. The rotated log files will use the
            following naming scheme, &amp;lt;filename&amp;gt;.0, &amp;lt;filename&amp;gt;.1, ..., &amp;lt;filename&amp;gt;.n-1.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:GCLogFileSize=8K&lt;/td&gt;
        &lt;td&gt;The size of the log file at which point the log will be rotated, must be &amp;gt;= 8K.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍3</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstat -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstata&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jstat/jstat.png&quot; alt=&quot;jstat_输出&quot; /&gt;
一张图理解用法&lt;/p&gt;

&lt;h2 id=&quot;options&quot;&gt;options&lt;/h2&gt;
&lt;p&gt;使用jstat -options可以查看支持的选项&lt;/p&gt;

&lt;p&gt;$ jstat -options&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-class 显示classLoader的相关信息&lt;/li&gt;
  &lt;li&gt;-compiler 显示JIT编译的相关信息&lt;/li&gt;
  &lt;li&gt;-gc 显示gc相关信息&lt;/li&gt;
  &lt;li&gt;-gccapacity 显示gc容量信息&lt;/li&gt;
  &lt;li&gt;-gccause 显示垃圾回收相关信息，同时显示最后一次或者当前正在发生的垃圾回收的诱发原因&lt;/li&gt;
  &lt;li&gt;-gcnew 显示新生代信息&lt;/li&gt;
  &lt;li&gt;-gcnewcapacity 显示新生代容量和大小情况&lt;/li&gt;
  &lt;li&gt;-gcold 显示老年代和永久代情况&lt;/li&gt;
  &lt;li&gt;-gcoldcapacity 显示老年代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcpermcapacity 显示永久代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcutil 显示垃圾收集信息（这个用的最多）&lt;/li&gt;
  &lt;li&gt;-printcompilation 输出JIT编辑的方法信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcyjstat--gcutil-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstat -gcutil 输出解释&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;更多解释请看http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们这里介绍一下用的最多的命令的输出&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
       413446.8  40.62   0.00  58.40  36.91      -      -    174   17.153     1    1.798   18.952
       413447.8  40.62   0.00  58.51  36.91      -      -    174   17.153     1    1.798   18.952
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;S0 S0占对应分配空间的利用百分比（理解S0,S1需要关注一下垃圾回收算法）&lt;/li&gt;
  &lt;li&gt;S1 S1占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;E	新生代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;O	老年代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;P	永久代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;YGC	young gc的次数&lt;/li&gt;
  &lt;li&gt;YGCT	young gc花费的时间&lt;/li&gt;
  &lt;li&gt;FGC	full gc次数&lt;/li&gt;
  &lt;li&gt;FGCT	full gc花费的时间&lt;/li&gt;
  &lt;li&gt;GCT	Total garbage collection time.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Jdk 命令行工具介绍2</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout:     post
title:      “JDK-命令行工具介绍2”
subtitle:   “ &quot;了解jstack的用法&quot;”
date:       2016-07-31 18:58:00
author:     “Dunno”
header-img: “img/post-bg-2015.jpg”
tags:
    - JVM
—&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstack&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
https://dzone.com/articles/how-analyze-java-thread-dumps
https://gist.github.com/rednaxelafx/843622&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstacka&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack 根据指定的端口或者远程debug服务打印出线程栈跟踪信息。&lt;/p&gt;

&lt;h2 id=&quot;jstack--l-7124-pid7124&quot;&gt;jstack -l 7124 打出pid为7124的线程栈跟踪信息&lt;/h2&gt;

&lt;p&gt;部分输出:&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.76-b04 mixed mode):

&amp;quot;Thread-11-EventThread&amp;quot; daemon prio=5 tid=0x00007f8e9d8e0000 nid=0x32327 waiting on condition [0x0000700013bca000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  &amp;lt;0x00000007eef76740&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:494)

   Locked ownable synchronizers:
	- None

&amp;quot;Thread-11-SendThread(10.4.241.128:2181)&amp;quot; daemon prio=5 tid=0x00007f8e9d857000 nid=0x2a33f runnable [0x0000700013ac7000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:200)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
	- locked &amp;lt;0x00000007eef75488&amp;gt; (a sun.nio.ch.Util$2)
	- locked &amp;lt;0x00000007eef75478&amp;gt; (a java.util.Collections$UnmodifiableSet)
	- locked &amp;lt;0x00000007eef75358&amp;gt; (a sun.nio.ch.KQueueSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
	at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:349)
	at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1081)

   Locked ownable synchronizers:
	- None
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjstack--l-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;“Thread-11-EventThread”&lt;/strong&gt; 线程名字，当使用Thread类生成的线程，thread会被命名成Thread-(Number)，而使用ThreadFactory类生成的线程会被命名成pool-(number)-thread-(number)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt; 如果有这一列代表是守护线程，没有则说明不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prio=5&lt;/strong&gt; 代表该线程的权值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tid=0x00007f8e9d857000&lt;/strong&gt; 代表该线程唯一的id（线程id），这个id是java层面的id&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nid=0x2a33f&lt;/strong&gt; 本地线程id(Native thread ID)，这个id的值依赖于系统平台层面。
    &lt;ul&gt;
      &lt;li&gt;windows下，就是操作系统级别的线程id&lt;/li&gt;
      &lt;li&gt;Linux下，nid是线程的pid （这里多提一句，我们大多场景是在linux上，当出现问题时，我们先可以利用 top -Hp 找出不正常的线程pid，把pid转成16进制（因为nid是16进制），然后根据这个转好的pid立马找到线程在干嘛，通常就能发现问题，top的用法，可以回滚之前的top使用的总结。 ）&lt;/li&gt;
      &lt;li&gt;Solaris下，nid是thr_self()的返回值&lt;/li&gt;
      &lt;li&gt;在Mac OS下，可以认为是本地pthread_t的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;waiting on condition [0x0000700013bca000] / runnable [0x0000700013ac7000]&lt;/strong&gt; 线程此时的状态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最后一栏&lt;/strong&gt; 代表线程调用的完整的堆栈信息&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</guid>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这里我们先介绍用法比较简单的几个命令:jps,jmap,jhat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjpsa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jps命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jps JVM进程状态工具

→ jps 列出进程id和main函数名称
7124 AppMain
10829 Jps

→ jps -q 只输出进程id
7124
10807

→ jps -m 输出进程id和主函数参数
7124 AppMain org.codehaus.classworlds.Launcher -Didea.version=15.0 clean jetty:run -Pperformance
10857 Jps -m

→ jps -l 只输出进程id和主函数路径
7124 com.intellij.rt.execution.application.AppMain
10888 sun.tools.jps.Jps

→ jps -v 输出进程id和给传递给jvm的参数（最常用）
7124 AppMain -Xms2048m -Xmx2048m -XX:PermSize=1024m -XX:MaxPermSize=1024m -Dmaven.home=/usr/local/apache-maven-3.1.1 -Dclassworlds.conf=/usr/local/apache-maven-3.1.1/bin/m2.conf -Didea.launcher.port=7533 -Didea.launcher.bin.path=/Applications/IntelliJ IDEA 15.app/Contents/bin -Dfile.encoding=UTF-8
10933 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home -Xms8m
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namejhatjhata&quot;&gt;&lt;a name=&quot;jhat&quot;&gt;jhat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jhat 堆dump游览器 - 启动一个web服务在一个堆dump文件上（比如使用jmap -dump产生的&lt;br /&gt;文件），可以在界面来浏览堆数据。

jhat -h 帮助

jhat filename 分析dump文件
在上面我们使用了jmap -dump:live,format=b,file=test 7124
现在我们来浏览一下数据

→ jhat test
Reading from test...
Dump file created Sun Jul 31 18:20:41 CST 2016
Snapshot read, resolving...
Resolving 4317462 objects...
WARNING:  Failed to resolve object id 0x788fe2078 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f382a8 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f37f40 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f19328 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f191b0 for field clazz (signature L)
WARNING:  Failed to resolve object id 0x788f18f90 for field clazz (signature L)
Chasing references, expect 863 dots..................................
Eliminating duplicate references..................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.

输出到这里说明已经ok了，那么接下来我们可以打开游览器，输入127.0.0.1:7000就可以浏览这些数据了
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jhat/jhat.png&quot; alt=&quot;jhat_输出&quot; /&gt;
游览器输出&lt;/p&gt;

&lt;h1 id=&quot;a-nametcyjmapa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jmap命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code&gt;
jmap java内存图 根据指定的进程id或者核心文件或者远程debug server输出对象或者堆内存的情况

jmap 或者 jmap -help 输出使用帮助 

jmap -histo:7124 打印堆对象柱状图
下面是部分输出：num:编号 instance:实例数量 byte:大小 class-类名

 num     #instances         #bytes  class name
----------------------------------------------
   1:       2251207      406535312  [C
   2:        328187      263542800  [B
   3:         90692       51871032  [I
   4:       1922400       46137600  java.lang.String
   5:       1121773       35896736  java.util.HashMap$Entry
   6:        237870       32585432  &lt;constmethodklass&gt;
   7:        783437       31337480  java.util.HashMap$KeyIterator
   8:        237870       30457760  &lt;methodklass&gt;
   9:         21767       25312768  &lt;constantpoolklass&gt;
   
jmap -dump:&lt;dump-option&gt;

dump-option:
live  指定了该选择则只dump live object，所有就dump堆中所有对象。
format=b 二进制格式
file=&lt;file&gt; 指定dump的具体文件
比如:
jmap -dump:live,format=b,file=test 7124


&lt;/file&gt;&lt;/dump-option&gt;&lt;/constantpoolklass&gt;&lt;/methodklass&gt;&lt;/constmethodklass&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/28/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Linux命令学习-找到大文件的目录</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前公司线下环境碰到过一个场景，运维通知某台机器磁盘快满了，需要尽快上去清理磁盘。但是我不知道如何快速的找到一些大文件的命令。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://man.linuxde.net/du&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkddua&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;du命令介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;du 预估文件空间使用情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-a,–all 输出所有文件大小，不仅仅是目录&lt;/li&gt;
  &lt;li&gt;-b,–bytes 按照bytes大小输出&lt;/li&gt;
  &lt;li&gt;-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。&lt;/li&gt;
  &lt;li&gt;-k或–kilobytes 以KB(1024bytes)为单位输出。&lt;/li&gt;
  &lt;li&gt;-m或–megabytes 以MB为单位输出。&lt;/li&gt;
  &lt;li&gt;-s或–summarize 仅显示总计，只列出最后加总的值。&lt;/li&gt;
  &lt;li&gt;-h或–human-readable 按照最适合的单位输出，提高信息的可读性，强烈推荐用这个，不需要-b -k -m了。&lt;/li&gt;
  &lt;li&gt;-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。&lt;/li&gt;
  &lt;li&gt;-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。&lt;/符号链接&gt;&lt;/符号链接&gt;&lt;/li&gt;
  &lt;li&gt;-s或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。&lt;/li&gt;
  &lt;li&gt;-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。&lt;/文件&gt;&lt;/文件&gt;&lt;/文件&gt;&lt;/li&gt;
  &lt;li&gt;–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。&lt;/目录或文件&gt;&lt;/li&gt;
  &lt;li&gt;-D或–dereference-args 显示指定符号链接的源文件大小。&lt;/li&gt;
  &lt;li&gt;-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。&lt;/li&gt;
  &lt;li&gt;-l或–count-links 重复计算硬件链接的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcya&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;例子&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录或者文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python
288	/home/heliang05/lib
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照指定单位输出大小(建议使用-h就行了)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
# du -b /home/heliang05
16593	/home/heliang05/bin
204846	/home/heliang05/lib/python/polysh
209287	/home/heliang05/lib/python

du -k /home/heliang05
20	/home/heliang05/bin
276	/home/heliang05/lib/python/polysh
284	/home/heliang05/lib/python

du -m /home/heliang05
1	/home/heliang05/bin
1	/home/heliang05/lib/python/polysh
1	/home/heliang05/lib/python
1	/home/heliang05/lib

du -h /home/heliang05
20K	/home/heliang05/bin
276K	/home/heliang05/lib/python/polysh
284K	/home/heliang05/lib/python
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询指定目录的大小（并不看其子目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
du -sh /home/heliang05
1.1M	/home/heliang05
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;-c 和 -a 和 -s的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;
建立测试数据（先建立一个depth1文件夹，然后在depth1里面建立一个depth的文件，同时在depth1里面简历depth2的文件夹，然后在depth2里面再建立一个depth文件）
mkdir depth1
cd depth1/
echo &quot;depth1&quot; &amp;gt; depth
mkdir depth2
cd depth2/
echo &quot;depth1&quot; &amp;gt; depth

测试不同命令的输出

du -ch depth1/
8.0K	depth1/depth2
16K	depth1/
16K	总用量

du -ah depth1/
4.0K	depth1/depth2/depth
8.0K	depth1/depth2
4.0K	depth1/depth
16K	depth1/

du -sh depth1/
16K	depth1/

结论：
-c 只会输出该目录下所有的文件及目录，不会继续输出子目录大小
-a 会输出当前目录以及子目录大小
-s 只会打出当面目录总和大小
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namedta&quot;&gt;&lt;a name=&quot;dt&quot;&gt;多提一句，删除文件&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;回到这次背景本身，我通过du命令找到了大文件时，需要删除无用文件，释放空间。
使用rm -rf的时候注意，可能无法释放空间，虽然删除了文件，但是文件还被其他应用使用的话，会导致仍然占用空间。
有一个还不错的方式是采用 &amp;gt; xxfile 来释放空间。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/25/Linux-%E6%89%BE%E5%88%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Java-mybatis generator返回主键的用法</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;用法介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;附：mybatis主键的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;用法介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;使用mybatis plugin,配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;install&amp;lt;/phase&amp;gt;
            &amp;lt;id&amp;gt;Generate MyBatis Artifacts&amp;lt;/id&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;configurationFile&amp;gt;src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
        &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;查看官方对于生成主键的配置的解释&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.mybatis.org/generator/configreference/generatedKey.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;generatorConfig.xml 配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nameckzlgeneratorconfiga&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;附：我的generatorConfig全部配置&lt;/a&gt;&lt;/h1&gt;

&lt;pre&gt;
&lt;code class=&quot;XML&quot;&gt;
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot; &amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;classPathEntry location=&amp;quot;/Users/lianghe/.m2/repository/mysql/mysql-connector-java/5.1.36/mysql-connector-java-5.1.36.jar&amp;quot;/&amp;gt;

    &amp;lt;context id=&amp;quot;mysql&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.EqualsHashCodePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.SerializablePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.ToStringPlugin&amp;quot; /&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.RowBoundsPlugin&amp;quot;/&amp;gt;
        &amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.CaseInsensitiveLikePlugin&amp;quot;/&amp;gt;

        &amp;lt;!-- &amp;#27880;&amp;#37322; --&amp;gt;
        &amp;lt;commentGenerator &amp;gt;
            &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#21462;&amp;#28040;&amp;#27880;&amp;#37322; --&amp;gt;
            &amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt; &amp;lt;!-- &amp;#26159;&amp;#21542;&amp;#29983;&amp;#25104;&amp;#27880;&amp;#37322;&amp;#20195;&amp;#26102;&amp;#38388;&amp;#25139;--&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;

        &amp;lt;!-- jdbc --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
                        connectionURL=&amp;quot;jdbc:mysql://xx.xx.xx.xx/hotel_pda&amp;quot;
                        userId=&amp;quot;xxx&amp;quot;
                        password=&amp;quot;xxx&amp;quot; /&amp;gt;
        &amp;lt;!-- &amp;#29983;&amp;#25104;model --&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.xxx.domain&amp;quot;
                            targetProject=&amp;quot;src/main/java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;mapper/auto&amp;quot;
                         targetProject=&amp;quot;src/main/resources&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;!-- &amp;#29983;&amp;#25104;sql client--&amp;gt;
        &amp;lt;javaClientGenerator targetPackage=&amp;quot;com.xxx.dao.auto&amp;quot;
                             targetProject=&amp;quot;src/main/java&amp;quot;
                             type=&amp;quot;XMLMAPPER&amp;quot; &amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;

        &amp;lt;!-- Tables --&amp;gt;
        &amp;lt;table schema=&amp;quot;hotel_pda&amp;quot; tableName=&amp;quot;vg_upload_file&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;useActualColumnNames&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
            &amp;lt;generatedKey column=&amp;quot;id&amp;quot; sqlStatement=&amp;quot;MySql&amp;quot; identity=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namexkdmybatisa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;附：mybatis返回主键的用法&lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;
&lt;code class=&quot;Java&quot;&gt;
public int insert(Domain domain) {
	//插入完成后 domain的主键id字段会被赋值，直接返回即可
	domainMapper.insertSelective(domain);
	return domain.getId();
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 04:09:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/23/Java-mybatis%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%9D%91/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
