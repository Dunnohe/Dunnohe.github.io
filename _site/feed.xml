<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno_he</title>
    <description>一个普通的程序员，喜欢动漫，游泳...
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 04 Nov 2015 17:39:58 +0800</pubDate>
    <lastBuildDate>Wed, 04 Nov 2015 17:39:58 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>哪个对象才是锁</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;哪个对象才是锁&lt;/h1&gt;

&lt;p&gt;首先回顾背景知识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于实例同步方法，锁是当前实例对象。&lt;/li&gt;
  &lt;li&gt;对于静态同步方法，锁是当前对象的Class对象。&lt;/li&gt;
  &lt;li&gt;对于同步方法块，锁是Synchonized括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;Class A{ 
	public static synchronized void write(boolean b){
  		isTrue = b;
	}
	public static synchronized boolean read(){
  	return isTrue;
	}
}&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;线程1访问A.write(true)方法时，线程2能访问A.read()方法吗？&lt;/li&gt;
  &lt;li&gt;线程1访问new A().write(false)方法时，线程2能访问new A().read()方法吗？&lt;/li&gt;
  &lt;li&gt;线程1访问A.write(false)方法时，线程2能访问new A().read()方法吗？&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;
public synchronized void write(boolean b){
  isTrue = b;
}

public synchronized boolean read(){
  return isTrue;
}
&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;A a=new A(); 线程1访问a.write(false)方法，线程2能访问a.read()方法吗？&lt;/li&gt;
  &lt;li&gt;A a=new A(); A b=new A();线程1访问a.write(false)方法，线程2能访问b.read()方法吗？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程1访问A.write()方法时，线程2能访问A.read()方法吗？不能，因为静态方法的锁都是A.Class对象,线程1拿到锁之后，线程2就拿不到锁了。&lt;/p&gt;

&lt;p&gt;线程1访问new A().write()方法时，线程2能访问new A().read()方法吗？不能，原因同上。&lt;/p&gt;

&lt;p&gt;线程1访问A.write()方法时，线程2能访问new A().read()方法吗？不能，原因同上&lt;/p&gt;

&lt;p&gt;A a=new A(); 线程1访问a.write()方法，线程2能访问a.read()方法吗？不能，因为这两个方法的锁都是对象a，线程1拿到了锁，线程2就不能访问了。&lt;/p&gt;

&lt;p&gt;A a=new A(); A b=new A();线程1访问a.write()方法，线程2能访问b.read()方法吗？可以，因为线程1拿到的是锁是 a,而线程2访问b.read()需要的是锁是b。&lt;/p&gt;

&lt;p&gt;现在你应该明白了这句话，对于实例同步方法，锁是当前实例对象。对于静态同步方法，锁是当前对象的Class对象。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Sep 2015 02:51:59 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2015/09/27/%E5%93%AA%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%89%8D%E6%98%AF%E9%94%81.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2015/09/27/%E5%93%AA%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%89%8D%E6%98%AF%E9%94%81.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>A Clean Jekyll theme</title>
        <description>&lt;h2 id=&quot;subheading&quot;&gt;Subheading&lt;/h2&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec at mauris ante. Cras sit amet porta quam. Donec eu gravida elit. Sed a diam eget sem lacinia maximus vel et elit. Nullam id egestas nulla. Duis dapibus at quam eu dapibus. Maecenas ullamcorper placerat eros, eu posuere enim bibendum eget. Phasellus mollis enim molestie tortor aliquam, nec auctor ligula &lt;code&gt;fringilla&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample Code&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;quot;net/http&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rw&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;rw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello world.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;:3000&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Do this&lt;/li&gt;
  &lt;li&gt;Do that&lt;/li&gt;
  &lt;li&gt;Bla Bla Bla&lt;/li&gt;
  &lt;li&gt;Go to Sleep&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Sep 2015 02:51:59 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2015/09/27/clean-theme.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2015/09/27/clean-theme.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>利用jekyll搭建博客</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;之前一直用云笔记去记录所学的东西，一直希望能有一个blog，能把自己的一些学习体会也发出来，让大家指正，同事给我推荐了jekyll+github来建造blog，正好放假有时间我就搭建了一个，把搭建经历分享一下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;资料&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;github page 使用 https://pages.github.com/&lt;/li&gt;
  &lt;li&gt;jekyll安装  http://jekyllrb.com/&lt;/li&gt;
  &lt;li&gt;jekyll的一些主题 http://jekyllthemes.org/&lt;/li&gt;
  &lt;li&gt;markdown 语法 http://wowubuntu.com/markdown/&lt;/li&gt;
  &lt;li&gt;markdown 工具 马克飞象 （可以云同步到印象笔记）&lt;/li&gt;
  &lt;li&gt;github page 使用帮助 https://help.github.com/categories/github-pages-basics/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;步骤&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本地安装jekyll，非常简单，地址：http://jekyllrb.com/&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt; $ gem install jekyll
~ $ jekyll new my-awesome-site
~ $ cd my-awesome-site
~/my-awesome-site $ jekyll serve
=&amp;gt; Now browse to http://localhost:4000
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进入你的github
    &lt;ul&gt;
      &lt;li&gt;建立一个代码仓库&lt;/li&gt;
      &lt;li&gt;代码仓库的名字必须是&lt;b&gt;username.github.io&lt;/b&gt;(比如我的用户名是Dunnohe,那么仓库必须叫Dunnohe.github.io)&lt;/li&gt;
      &lt;li&gt;把仓库clone到本地&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/username/username.github.io&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载你喜欢的jekyll主题 http://jekyllthemes.org/&lt;/li&gt;
  &lt;li&gt;然后把下好的主题的代码copy到你本地clone下来的仓库根目录
    &lt;ul&gt;
      &lt;li&gt;比如我的主题叫xx-theme, 仓库文件下路径在~/github&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
cd ~/Downloads/xx-theme
sudo cp -r * ~/github/Dunnohe.github.io
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发布到github上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
git status
git add .
git commit -am &quot;first edition&quot;
git push origin master
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;到此就设置完毕了，可以通过访问http://username.github.io来访问了&lt;/li&gt;
  &lt;li&gt;blog的编写是采用markdown语法，语法很简单，上面有链接，有很多支持markdown的编辑器，而且有些编辑器可以同步到云笔记，很方便。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Sep 2015 02:51:59 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2015/09/27/blog.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2015/09/27/blog.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>java一些常用的性能调优工具和命令</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;最近的工作中，和带我的到时一起做了一个项目，加载所有数据到内存，然后做分片访问，在发布几个版本之后，监控发现内存泄露了，我感觉这种问题十分难以定位，但是同事用各种监控的命令发现泄漏的地方，我感觉很有必要总结学习一下&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;JDK的安装包提供了很多辅助工具用来监测数据。&lt;/p&gt;

&lt;h4 id=&quot;jps&quot;&gt;jps&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：这个命令类似于linux下的ps命令，但它只能显示java的进程&lt;/li&gt;
  &lt;li&gt;选项：
    &lt;ul&gt;
      &lt;li&gt;-q   只输出输出进程id&lt;/li&gt;
      &lt;li&gt;-m  输出用于传递java主函数的参数&lt;/li&gt;
      &lt;li&gt;-l    输出完整的应用程序主类包名或者应用程序jar的完整路径&lt;/li&gt;
      &lt;li&gt;-v   输出传给JVM的参数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;jps -mlv&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;jinfo&quot;&gt;jinfo&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：可以查看正在运行的java应用程序的拓展参数，甚至支持在运行时修改部分参数。
    &lt;ul&gt;
      &lt;li&gt;-flag &lt;name&gt; : 打印指定JVM的参数值&lt;/name&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;-flag [+&lt;/td&gt;
              &lt;td&gt;-] &lt;name&gt; : 设置指定JVM的参数值&lt;/name&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;-flag &lt;name&gt; = &lt;value&gt; :  设置指定JVM的参数值&lt;/value&gt;&lt;/name&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jmap&quot;&gt;jmap&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：可以生成java应用程序的堆快照和对象的统计信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个命令很好用，就是靠他我们发现某几个实体对象数量特别多，再检查处理那块实体逻辑才发现bug的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//显示pid为2972的java程序的统计信息
jmap -histo 2972
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;jstat&quot;&gt;jstat&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：用于观察java运行时信息的工具。非常强大&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;用法：jstat[generalOption&lt;/td&gt;
          &lt;td&gt;outputOptions vmid [interval[s&lt;/td&gt;
          &lt;td&gt;ms] [count]]]&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;选项：
    &lt;ul&gt;
      &lt;li&gt;generalOption 这项取值是一些帮助和选择就不说了，可以man jstat看一下&lt;/li&gt;
      &lt;li&gt;help –display help message&lt;/li&gt;
      &lt;li&gt;options –display help message&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 03 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2015/07/03/java-monitor.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2015/07/03/java-monitor.html</guid>
        
        <category>jvm</category>
        
        <category>linux</category>
        
        <category>java</category>
        
        
      </item>
    
  </channel>
</rss>
