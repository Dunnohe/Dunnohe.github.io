<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dunno Blog</title>
    <description>Do not go gentle into that good night.Rage, rage against the dying of the light.</description>
    <link>http://dunnohe.github.io/</link>
    <atom:link href="http://dunnohe.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 02 Oct 2016 14:03:28 +0800</pubDate>
    <lastBuildDate>Sun, 02 Oct 2016 14:03:28 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;加载的入口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前已经简单的总结了spring读取xml配置到注册容器的整个过程。但是实际工作中我们会大量的使用到annotation，annotation注册到容器的过程是如何的呢。&lt;/p&gt;

&lt;h1 id=&quot;a-namedmlja&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;加载的入口&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;之前我们就了解到，加载的入口在AbstractRefreshableApplicationContext的loadBeanDefinitions方法，我们看一下这个方法的实现，发现有annotation的实现版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/7/access.png&quot; alt=&quot;IOC容器结构&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;annotationloadbeandefinitions&quot;&gt;1,Annotation版本对于loadBeanDefinitions方法的实现&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class AnnotationConfigWebApplicationContext extends AbstractRefreshableWebApplicationContext
		implements AnnotationConfigRegistry {

	private BeanNameGenerator beanNameGenerator;

	private ScopeMetadataResolver scopeMetadataResolver;

	private final Set&amp;lt;Class&lt;?&gt;&gt; annotatedClasses = new LinkedHashSet&lt;Class&lt;?&gt;&amp;gt;();

	private final Set&lt;string&gt; basePackages = new LinkedHashSet&lt;string&gt;();
	
	@Override
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {
		AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);
		ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);

		BeanNameGenerator beanNameGenerator = getBeanNameGenerator();
		if (beanNameGenerator != null) {
			reader.setBeanNameGenerator(beanNameGenerator);
			scanner.setBeanNameGenerator(beanNameGenerator);
			beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
		}

		ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
		if (scopeMetadataResolver != null) {
			reader.setScopeMetadataResolver(scopeMetadataResolver);
			scanner.setScopeMetadataResolver(scopeMetadataResolver);
		}

		if (!this.annotatedClasses.isEmpty()) {
			if (logger.isInfoEnabled()) {
				logger.info(&quot;Registering annotated classes: [&quot; +
						StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + &quot;]&quot;);
			}
			reader.register(this.annotatedClasses.toArray(new Class&lt;?&gt;[this.annotatedClasses.size()]));
		}

		if (!this.basePackages.isEmpty()) {
			if (logger.isInfoEnabled()) {
				logger.info(&quot;Scanning base packages: [&quot; +
						StringUtils.collectionToCommaDelimitedString(this.basePackages) + &quot;]&quot;);
			}
			scanner.scan(this.basePackages.toArray(new String[this.basePackages.size()]));
		}

		String[] configLocations = getConfigLocations();
		if (configLocations != null) {
			for (String configLocation : configLocations) {
				try {
					Class&lt;?&gt; clazz = getClassLoader().loadClass(configLocation);
					if (logger.isInfoEnabled()) {
						logger.info(&quot;Successfully resolved class for [&quot; + configLocation + &quot;]&quot;);
					}
					reader.register(clazz);
				}
				catch (ClassNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not load class for config location [&quot; + configLocation +
								&quot;] - trying package scan. &quot; + ex);
					}
					int count = scanner.scan(configLocation);
					if (logger.isInfoEnabled()) {
						if (count == 0) {
							logger.info(&quot;No annotated classes found for specified class/package [&quot; + configLocation + &quot;]&quot;);
						}
						else {
							logger.info(&quot;Found &quot; + count + &quot; annotated classes in package [&quot; + configLocation + &quot;]&quot;);
						}
					}
				}
			}
		}
	}
}






&lt;/string&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Sep 2016 07:43:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A67%E4%BA%86%E8%A7%A3annotation%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%88%B0IOC%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A67%E4%BA%86%E8%A7%A3annotation%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%88%B0IOC%E5%AE%B9%E5%99%A8/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;具体解析bean的过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;上一篇学习笔记跟了大半天，才跟到加载bean解析的入口，这篇学习笔记则学习一下具体的解析部分以及注册到容器的代码。&lt;/p&gt;

&lt;h1 id=&quot;a-namedmljbeana&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;具体解析bean的过程&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;我们继续从refreshBeanFactory开始看起，它的作用是通知子类去刷新自己的bean容器。&lt;/p&gt;

&lt;h2 id=&quot;doregisterbeandefinitionsbean&quot;&gt;1,doRegisterBeanDefinitions方法（具体解析bean的入口）&lt;/h2&gt;
&lt;p&gt;这里可以把refresh理解成xxapplicationcontext的重启方法，refreshBeanFactory理解成bean容器的重启方法。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		//如果使用默认的命名空间
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			for (int i = 0; i &amp;lt; nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					//如果元素使用的是默认命名空间
					if (delegate.isDefaultNamespace(ele)) {
						//解析默认元素
						parseDefaultElement(ele, delegate);
					}
					else {
						//解析定制元素
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			//解析定制元素
			delegate.parseCustomElement(root);
		}
	}
	
	//解析默认元素
	private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
	
		//1，如果是import node
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			//解析import 资源
			importBeanDefinitionResource(ele);
		}
		
		//2，如果是alias node
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			//处理alias 资源
			processAliasRegistration(ele);
		}
		
		//3，如果是bean node
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			//处理bean node
			processBeanDefinition(ele, delegate);
		}
		
		//4，如果是 beans node
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// 递归执行doRegisterBeanDefinitions，又回到了解析的入口函数了
			doRegisterBeanDefinitions(ele);
		}
	}
	
	//我们来重点看看3和4的实现，先看3的
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		
		//把element解析成BeanDefinitionHolder
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// 注册bean到容器.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +
						bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);
			}
			// 发送注册事件，这个很重要，我们可以通过实现对应的监听器来获得这个bean注册的信息了。
			// 既然这里有事件，那我们很容易联想到1，2是不是也有对应的事件？点开验证一下
			// 果然有对应的事件，分别是fireImportProcessed，fireAliasRegistered
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
}
	
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;registerbeandefinitionbean&quot;&gt;2,registerBeanDefinition（具体把bean注册到容器的入口）&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class BeanDefinitionReaderUtils {
	public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {

		// beanName会从id属性拿，否则就自动构建defaultName，调用buildDefaultName（）
		String beanName = definitionHolder.getBeanName();
		// 注册
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		//注册设置了别名的bean
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
}
	
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;defaultlistablebeanfactory-&quot;&gt;DefaultListableBeanFactory （注册的具体过程）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
	@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						&quot;Validation of bean definition failed&quot;, ex);
			}
		}

		BeanDefinition oldBeanDefinition;
		//beanDefinitionMap 这个就是“容器”的本质了，它的结构是这样的，beanName-beanDefinition
		oldBeanDefinition = this.beanDefinitionMap.get(beanName);
		
		//如果容器里面已经有这个beanDefinition，会根据相应的判断，给出相应的日志提示，建议启动关注这块日志，实际规范的项目不应该让他打出这个日志，打出来了建议找到对应的地方改掉。可能会造成故障。
		if (oldBeanDefinition != null) {
			//是否允许覆盖，不允许就抛异常
			if (!isAllowBeanDefinitionOverriding()) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +
						&quot;&#39;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);
			}
			//
			else if (oldBeanDefinition.getRole() &amp;lt; beanDefinition.getRole()) {
				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
				if (this.logger.isWarnEnabled()) {
					this.logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +
							&quot;&#39; with a framework-generated bean definition: replacing [&quot; +
							oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else if (!beanDefinition.equals(oldBeanDefinition)) {
				if (this.logger.isInfoEnabled()) {
					this.logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +
							&quot;&#39; with a different definition: replacing [&quot; + oldBeanDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else {
				if (this.logger.isDebugEnabled()) {
					this.logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +
							&quot;&#39; with an equivalent definition: replacing [&quot; + oldBeanDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			//新的beanDefinition放到容器里面
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			//如果容器是第一次注册这个definition的话
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;string&gt; updatedDefinitions = new ArrayList&lt;string&gt;(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					if (this.manualSingletonNames.contains(beanName)) {
						Set&lt;string&gt; updatedSingletons = new LinkedHashSet&lt;string&gt;(this.manualSingletonNames);
						updatedSingletons.remove(beanName);
						this.manualSingletonNames = updatedSingletons;
					}
				}
			}
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
				this.manualSingletonNames.remove(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}

		if (oldBeanDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
	}
}
	



&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Sep 2016 07:43:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A66%E4%BA%86%E8%A7%A3BeanDefition%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%88%B0IOC%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A66%E4%BA%86%E8%A7%A3BeanDefition%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%88%B0IOC%E5%AE%B9%E5%99%A8/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;BeanDefition的Resource定位&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这里我们一起了解一下IOC容器是如何载入和解析bean的&lt;/p&gt;

&lt;h1 id=&quot;a-namedmljbeandefitionresourcea&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;了解BeanDefition的Resource载入和解析&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;我们继续从refreshBeanFactory开始看起，它的作用是通知子类去刷新自己的bean容器。&lt;/p&gt;

&lt;h2 id=&quot;refreshbeanfactorybeanfactory&quot;&gt;1,refreshBeanFactory方法（刷新beanFactory）&lt;/h2&gt;
&lt;p&gt;这里可以把refresh理解成xxapplicationcontext的重启方法，refreshBeanFactory理解成bean容器的重启方法。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {

	@Override
	protected final void refreshBeanFactory() throws BeansException {
		//如果已经创建的bean容器
		if (hasBeanFactory()) {
			//清除已经创建的beans
			destroyBeans();
			//关闭beanfactory容器
			closeBeanFactory();
		}
		try {
			//创建beanfactory，可见默认使用的beanfactory容器是这个啊。
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			beanFactory.setSerializationId(getId());
			//这里面设置beanfactory是否支持“bean覆盖”和“循环引用”两种选项
			customizeBeanFactory(beanFactory);
			//加载bean resource
			loadBeanDefinitions(beanFactory);
			//设置beanfactory属性
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
			}
		}
		catch (IOException ex) {
			throw new ApplicationContextException(&amp;quot;I/O error parsing bean definition source for &amp;quot; + getDisplayName(), ex);
		}
	}
	
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;loadbeandefinitions&quot;&gt;2,loadBeanDefinitions（加载以及解析配置文件）&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {

	@Override
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
		// 由这里可以看到默认读取Xml的reader是这个
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

		// Configure the bean definition reader with this context&#39;s
		// resource loading environment.
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		initBeanDefinitionReader(beanDefinitionReader);
		//具体加载beanDefinition的方法
		loadBeanDefinitions(beanDefinitionReader);
	}
	
	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
		
		//通过resource方法加载bean	
		Resource[] configResources = getConfigResources();
		if (configResources != null) {
			reader.loadBeanDefinitions(configResources);
		}
		
		//通过string的形式加载bean
		String[] configLocations = getConfigLocations();
		if (configLocations != null) {
			reader.loadBeanDefinitions(configLocations);
		}
	}
}
	
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;bean&quot;&gt;3,bean的加载和解析&lt;/h2&gt;

&lt;h3 id=&quot;string-pathbean&quot;&gt;我们先来看看通过String path来加载bean的实现&lt;/h3&gt;

&lt;p&gt;因为最终他和resource加载bean的方式一样，都是通过resource加载。只不过String加载bean多了一步，把String解析成resource。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {
	public int loadBeanDefinitions(String location, Set&amp;lt;Resource&amp;gt; actualResources) throws BeanDefinitionStoreException {
		//获得resourceloader，获得不到抛异常	
		ResourceLoader resourceLoader = getResourceLoader();
		if (resourceLoader == null) {
			throw new BeanDefinitionStoreException(
					&amp;quot;Cannot import bean definitions from location [&amp;quot; + location + &amp;quot;]: no ResourceLoader available&amp;quot;);
		}

		//如果resourceloader是ResourcePatternResolver（支持把通配符配置解析成多个resource，比如&amp;quot;/WEB-INF/*-context.xml&amp;quot;），则获得对应解析出的多个resource
		if (resourceLoader instanceof ResourcePatternResolver) {
			// Resource pattern matching available.
			try {
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
				//这里面是for循环去加载和解析，实际就是调用下面的“单个解析resource的方法”。
				//同时在通过resource 来解析bean的实现中也是调用“单个解析resource的方法”。
				//所以，我们最终看这个调用单个resource方法的实现就行了。
				int loadCount = loadBeanDefinitions(resources);
				if (actualResources != null) {
					for (Resource resource : resources) {
						actualResources.add(resource);
					}
				}
				if (logger.isDebugEnabled()) {
					logger.debug(&amp;quot;Loaded &amp;quot; + loadCount + &amp;quot; bean definitions from location pattern [&amp;quot; + location + &amp;quot;]&amp;quot;);
				}
				return loadCount;
			}
			catch (IOException ex) {
				throw new BeanDefinitionStoreException(
						&amp;quot;Could not resolve bean definition resource pattern [&amp;quot; + location + &amp;quot;]&amp;quot;, ex);
			}
		}
		//反之获得对应解析的单个resource
		else {
			Resource resource = resourceLoader.getResource(location);
			//调用单个解析resource的方法，这个方法就是最终加载解析bean的底层公用方法
			int loadCount = loadBeanDefinitions(resource);
			if (actualResources != null) {
				actualResources.add(resource);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(&amp;quot;Loaded &amp;quot; + loadCount + &amp;quot; bean definitions from location [&amp;quot; + location + &amp;quot;]&amp;quot;);
			}
			return loadCount;
		}
	}
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;resource&quot;&gt;4,最终底层调用的单个解析resource的方法&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	@Override
	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		//EncodedResource 多了一些对编码属性的设置
		return loadBeanDefinitions(new EncodedResource(resource));
	}
	
	//从指定的resource文件中加载bean
	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
		Assert.notNull(encodedResource, &amp;quot;EncodedResource must not be null&amp;quot;);
		if (logger.isInfoEnabled()) {
			logger.info(&amp;quot;Loading XML bean definitions from &amp;quot; + encodedResource.getResource());
		}

		//resourcesCurrentlyBeingLoaded用来存放“正在加载中”的配置文件，通过threadlocal实现的。
		//放资源的时候，没有就创建并且放进去，有就直接放
		Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
		if (currentResources == null) {
			currentResources = new HashSet&amp;lt;EncodedResource&amp;gt;(4);
			this.resourcesCurrentlyBeingLoaded.set(currentResources);
		}
		if (!currentResources.add(encodedResource)) {
			throw new BeanDefinitionStoreException(
					&amp;quot;Detected cyclic loading of &amp;quot; + encodedResource + &amp;quot; - check your import definitions!&amp;quot;);
		}
		try {
			InputStream inputStream = encodedResource.getResource().getInputStream();
			try {
				InputSource inputSource = new InputSource(inputStream);
				if (encodedResource.getEncoding() != null) {
					inputSource.setEncoding(encodedResource.getEncoding());
				}
				//具体去单个加载一个配置文件的实现（这个层级好深啊。。。。）
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
			}
			finally {
				inputStream.close();
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&amp;quot;IOException parsing XML document from &amp;quot; + encodedResource.getResource(), ex);
		}
		finally {
			//加载流程结束，移除“正在被加载”的配置文件
			currentResources.remove(encodedResource);
			//移除threadlocal里面的hashset
			if (currentResources.isEmpty()) {
				this.resourcesCurrentlyBeingLoaded.remove();
			}
		}
	}
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;5,具体去单个加载一个配置文件的实现&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {

	protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {
		try {
			//解析配置文件，同时验证document的语法，得到document
			Document doc = doLoadDocument(inputSource, resource);
			//注册bean
			return registerBeanDefinitions(doc, resource);
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
	
	//注册bean
	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
		int countBefore = getRegistry().getBeanDefinitionCount();
		//具体注册bean的方法（按照spring的尿性肯定还有好几层，而且名字相似）
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
		return getRegistry().getBeanDefinitionCount() - countBefore;
	}
	
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;beandefinitiondocumentreaderdocument&quot;&gt;6,BeanDefinitionDocumentReader（负责将解析好的document注册到容器中）&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//注册接口
public interface BeanDefinitionDocumentReader {
	void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)
			throws BeanDefinitionStoreException;
}

public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {

	@Override
	public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
		this.readerContext = readerContext;
		logger.debug(&quot;Loading bean definitions&quot;);
		Element root = doc.getDocumentElement();
		doRegisterBeanDefinitions(root);
	}
	
	protected void doRegisterBeanDefinitions(Element root) {

		BeanDefinitionParserDelegate parent = this.delegate;
		this.delegate = createDelegate(getReaderContext(), root, parent);

		if (this.delegate.isDefaultNamespace(root)) {
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					return;
				}
			}
		}

		//空方法，没有实现，也体现了人家先做好设计，再填实现的编码过程
		preProcessXml(root);
		//这里就是最底层载入和解析的入口了，接下来它就会交给BeanDefinitionDocumentReader去做具体的解析过程了。
		//下一篇学习笔记来总结具体的解析过程。
		parseBeanDefinitions(root, this.delegate);
		//空方法没有实现
		postProcessXml(root);

		this.delegate = parent;
	}
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Tue, 06 Sep 2016 07:43:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A65%E4%BA%86%E8%A7%A3BeanDefition%E7%9A%84Resource%E8%BD%BD%E5%85%A5%E5%92%8C%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/09/06/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A65%E4%BA%86%E8%A7%A3BeanDefition%E7%9A%84Resource%E8%BD%BD%E5%85%A5%E5%92%8C%E8%A7%A3%E6%9E%90/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;BeanDefition的Resource定位&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前我们了解了IOC初略的一个结构，这里我们开始学习一下spring是如何定位资源的。（桶子到哪里装水）&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;spring 技术内幕&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namedmljbeandefitionresourcea&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;BeanDefition的Resource定位&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;我们以FileSystemXmlApplicationContext为例，看一下它的类图（图片如果不清楚，可以右键保存下来看），我们主要观察蓝色线条的部分：
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/3/applicationcontext.png&quot; alt=&quot;IOC容器结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个关系是这样的：FileSystemXmlApplicationContext --》 AbstractXmlApplicationContext --》 AbstractRefreshableConfigApplicationContext --》 AbstractApplicationContext --》  DefaultResourceLoader&lt;/p&gt;

&lt;p&gt;下面我们从FileSystemXmlApplicationContext代码开始看起：&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;容器使用的入口&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public class FileSystemXmlApplicationContext extends AbstractXmlApplicationContext {
	
	//其他构造方法最终的都是调用这个方法
	public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {
		
		super(parent);
		//设置配置以及解析
		setConfigLocations(configLocations);
		if (refresh) {
			//启动容器
			refresh();
		}
	}

	@Override
	protected Resource getResourceByPath(String path) {
		if (path != null &amp;amp;&amp;amp; path.startsWith(&quot;/&quot;)) {
			path = path.substring(1);
		}
		return new FileSystemResource(path);
	}
	
	public void setConfigLocations(String... locations) {
		if (locations != null) {
			Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);
			//深复制配置文件到自身属性
			this.configLocations = new String[locations.length];
			for (int i = 0; i &amp;lt; locations.length; i++) {
				//挨个解析配置文件引入的占位符properties
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;设置配置以及解析&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext
		implements BeanNameAware, InitializingBean {
	
	public void setConfigLocations(String... locations) {
		if (locations != null) {
			Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);
			//深复制配置文件到自身属性
			this.configLocations = new String[locations.length];
			for (int i = 0; i &amp;lt; locations.length; i++) {
				//挨个解析配置文件引入的占位符properties
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;启动容器&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext, DisposableBean {
	
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// 为容器的启动做一些准备：设置对应状态属性。如果是web应用，同时会加载对应的属性。
			prepareRefresh();

			// 通知实现方去刷新内置的bean容器。前面我们讲到beanfactory的作用就是用来“装东西”的，那我们来看看这个里面的实现。
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset &#39;active&#39; flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring&#39;s core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;beanfactory&quot;&gt;通知子类刷新内置的beanfactory&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		//步骤1：刷新beanFactory
		refreshBeanFactory();
		
		//步骤2：获得beanfactory，这里的实现很简单，直接返回xxxapplicationcontext的beanfactory的属性。beanfactory属性的设置实在步骤1完成的。
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
		}
		return beanFactory;
	}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;beanfactory-1&quot;&gt;刷新内置的beanfactory具体实现&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {

	@Override
	protected final void refreshBeanFactory() throws BeansException {
		//如果已经创建的bean容器
		if (hasBeanFactory()) {
			//清除已经创建的beans
			destroyBeans();
			//关闭beanfactory容器
			closeBeanFactory();
		}
		try {
			//创建beanfactory，可见默认使用的beanfactory容器是这个啊。
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			beanFactory.setSerializationId(getId());
			//这里面设置beanfactory是否支持“bean覆盖”和“循环引用”两种选项
			customizeBeanFactory(beanFactory);
			//加载bean resource
			loadBeanDefinitions(beanFactory);
			//设置beanfactory属性
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
			}
		}
		catch (IOException ex) {
			throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
		}
	}
	
}

//看看容器是怎么创建的
protected DefaultListableBeanFactory createBeanFactory() {
		return new DefaultListableBeanFactory(getInternalParentBeanFactory());
	}
	
//如果双亲上下文实现了ConfigurableApplicationContext，那么返回双亲上下文的beanfactory，否则直接返回双亲上下文	
protected BeanFactory getInternalParentBeanFactory() {
		return (getParent() instanceof ConfigurableApplicationContext) ?
				((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();
	}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;资源的定位以及加载配置文件&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
//这里只贴出部分核心的代码
public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {

	@Override
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
		// 由这里可以看到默认读取Xml的reader是这个
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

		// Configure the bean definition reader with this context&#39;s
		// resource loading environment.
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		initBeanDefinitionReader(beanDefinitionReader);
		//具体加载beanDefinition的方法
		loadBeanDefinitions(beanDefinitionReader);
	}
}

//我们先来看看XmlBeanDefinitionReader里面干了什么？
public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {
		super(registry);
	}
//进入super方法看看，这个方法逻辑是根据beanFactory创建一个reader
//如果这个beanFactory不仅实现了BeanDefinitionRegistry，还实现了ResourceLoader的话，就把他设置成
//resourceloader，否则就创建一个默认的resourceloader。
//这个默认的resourceloader就是DefaultResourceLoader()。
//environment用了类似的逻辑
protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {
		Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
		this.registry = registry;

		// Determine ResourceLoader to use.
		if (this.registry instanceof ResourceLoader) {
			this.resourceLoader = (ResourceLoader) this.registry;
		}
		else {
			this.resourceLoader = new PathMatchingResourcePatternResolver();
		}

		// Inherit Environment if possible
		if (this.registry instanceof EnvironmentCapable) {
			this.environment = ((EnvironmentCapable) this.registry).getEnvironment();
		}
		else {
			this.environment = new StandardEnvironment();
		}
	}	
}
	
&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Sat, 27 Aug 2016 03:51:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/27/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A64%E4%BA%86%E8%A7%A3BeanDefition%E7%9A%84Resource%E5%AE%9A%E4%BD%8D/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/27/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A64%E4%BA%86%E8%A7%A3BeanDefition%E7%9A%84Resource%E5%AE%9A%E4%BD%8D/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;IOC容器的设计&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#bean&quot;&gt;xxxBeanFactory&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#res&quot;&gt;ResourceLoader&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#app&quot;&gt;xxxApplicationContext&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们学习一下容器具体是怎么启动的&lt;/p&gt;
&lt;p&gt;我这里学习的spring4的代码，和spring3的有些出入。可以checkout 4.x版本观看&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;spring 技术内幕&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namedmljioca&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;IOC容器结构&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;拿FileSystemXmlApplicationContext做例子，我们来看一下它的类图:
&lt;br /&gt;
图片如果不清楚，可以右键保存下来看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/3/applicationcontext.png&quot; alt=&quot;IOC容器结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常我们使用spring时，最直接的感受就是不用new对象了，spring已经直接帮我们实现new好了，然后放到一个容器里面，我们每次注入的时候实际就是去容器里面去拿。&lt;/p&gt;

&lt;p&gt;上面的图主要有三大部分，一个是xxxBeanFactory,一个是xxxApplicationContext,一个是ResourceLoader，还有一些其他的接口,比如ApplicationEventPublisher(事件发布)，我们后面再学习。&lt;/p&gt;

&lt;h2 id=&quot;a-namebeanxxxbeanfactorya&quot;&gt;&lt;a name=&quot;bean&quot;&gt;xxxBeanFactory&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;beanFactory bean的工厂，顾名思义，这个xxxBeanFactory就是容器了。我们其实就可以理解成装实体的桶子就行了，那么beanFactory里面封装的方法都是和&lt;strong&gt;[容器属性]&lt;/strong&gt;相关的方法。比如如果我们设计，我们可以第一想到：容器多大啊，能装多少东西啊，装了啥啊之类的东西。&lt;/p&gt;

&lt;h3 id=&quot;beanfactory&quot;&gt;BeanFactory&lt;/h3&gt;

&lt;pre&gt;
&lt;code&gt;
//封装了一些基本的访问bean的方法
public interface BeanFactory {
	//&amp;amp;xxxbean对象拿到的是xxxbean对应的factorybean
	String FACTORY_BEAN_PREFIX = &amp;quot;&amp;amp;&amp;quot;;

	Object getBean(String name) throws BeansException;

	&amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException;

	&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;

	Object getBean(String name, Object... args) throws BeansException;

	&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;

	boolean containsBean(String name);

	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;

	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;

	boolean isTypeMatch(String name, Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;

	Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;

	String[] getAliases(String name);

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;hierarchicalbeanfactory&quot;&gt;HierarchicalBeanFactory&lt;/h3&gt;

&lt;pre&gt;
&lt;code&gt;
//在BeanFactory基础上加了获得父BeanFactory的方法
public interface HierarchicalBeanFactory extends BeanFactory {

	BeanFactory getParentBeanFactory();

	boolean containsLocalBean(String name);

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;configurablebeanfactory&quot;&gt;ConfigurableBeanFactory&lt;/h3&gt;
&lt;p&gt;在HierarchicalBeanFactory的基础上增加了一些对BeanFactory的配置功能，比如setParentBeanFactory()设置双亲IOC容器。&lt;/p&gt;

&lt;h3 id=&quot;listablebeanfactory&quot;&gt;ListableBeanFactory&lt;/h3&gt;
&lt;p&gt;在BeanFactory基础上增加了对容器bean的各种属性查询方法。&lt;/p&gt;

&lt;h2 id=&quot;a-nameresresourceloadera&quot;&gt;&lt;a name=&quot;res&quot;&gt;ResourceLoader&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ResourceLoader,顾名思义：资源加载者。前面讲到了把beanFactory理解成装实体的桶子，那么我们到怎么装呢？到哪里去装呢？这就是ResourceLoader负责的了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public interface ResourceLoader {
	//这个值是classpath:  方便classpathresource时使用
	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;
	//获得资源，也就是告诉你装东西的地址
	Resource getResource(String location);
	//
	ClassLoader getClassLoader();

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;a-nameappxxxapplicationcontexta&quot;&gt;&lt;a name=&quot;app&quot;&gt;xxxApplicationContext&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;它是一个更高级的容器，容器只是它的一个子功能，同时它还支持其他特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持国际化 多语言版本的支持(MessageSource)&lt;/li&gt;
  &lt;li&gt;访问资源 容器加载bean是要有一个加载源的，这个resource就是加载源。&lt;/li&gt;
  &lt;li&gt;支持应用事件 在整个bean的声明周期中，需要引入应用事件，便于更好的管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;applicationContext怎么理解呢，你就把它理解成一个工具箱，里面放了桶子（xxBeanFactory），还放了给桶子装东西的方法(resourcesLoader),还有中英文说明书（MessageSource）,还有遥控器可以遥控桶子（ApplicationEventPublisher）。有了这些大工具箱，你能想到的启动容器的条件是不是就都具备了！&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A63%E4%BA%86%E8%A7%A3IOC%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A63%E4%BA%86%E8%A7%A3IOC%E5%AE%B9%E5%99%A8/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在大多数使用spring的项目场景来说，都是web项目。那我们先从入口开始学习，了解spring是如何启动的。&lt;/p&gt;
&lt;p&gt;我这里学习的spring4的代码，和spring3的有些出入。可以checkout 4.x版本观看&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/ 7.15.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namedmlja&quot;&gt;&lt;a name=&quot;dmlj&quot;&gt;代码了解&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;application&quot;&gt;注册Application&lt;/h2&gt;

&lt;p&gt;首先web 项目应用是通过ContextLoaderListener来注册Applicationcontext的。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;

&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;contextloaderlistener&quot;&gt;ContextLoaderListener代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
	public ContextLoaderListener() {
	}

	public ContextLoaderListener(WebApplicationContext context) {
		super(context);
	}

	@Override
	public void contextInitialized(ServletContextEvent event) {
		//初始化根上下文信息
		initWebApplicationContext(event.getServletContext());
	}

	@Override
	public void contextDestroyed(ServletContextEvent event) {
		//关闭根上下文信息
		closeWebApplicationContext(event.getServletContext());
		//清除初始化过程中种下的一些属性
		ContextCleanupListener.cleanupAttributes(event.getServletContext());
	}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ioc&quot;&gt;具体初始化IOC容器代码&lt;/h2&gt;

&lt;pre&gt;
&lt;code&gt;
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
		
		//判断是否已经种下了根上下文，没有就抛出异常
		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
			throw new IllegalStateException(
					&quot;Cannot initialize context because there is already a root application context present - &quot; +
					&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
		}

		Log logger = LogFactory.getLog(ContextLoader.class);
		servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
		if (logger.isInfoEnabled()) {
			logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
			
			//创建上下文信息
			if (this.context == null) {
				//该方法逻辑：这里不贴具体代码了，太多了
				//1，从servletcontext上下文中拿到对应初始化参数
				//2，生成实例类
				//3，确保该实例类来源于ConfigurableWebApplicationContext,否则抛出异常
				//4，将这个类转成webapplicationcontext并且返回出去
				this.context = createWebApplicationContext(servletContext);
			}

			//确保上下文信息来源了ConfigurableWebApplicationContext
			if (this.context instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
				if (!cwac.isActive()) {
					// The context has not yet been refreshed -&amp;gt; provide services such as
					// setting the parent context, setting the application context id, etc
					if (cwac.getParent() == null) {
						// The context instance was injected without an explicit parent -&amp;gt;
						// determine parent for root web application context, if any.
						//获得双亲上下文，并且设置进来
						ApplicationContext parent = loadParentContext(servletContext);
						cwac.setParent(parent);
					}

					//逻辑：这里不贴具体代码了，太多了
					//1，里面设置了webApplicationContext的相关属性
					//2，调用webapplicationContext的refresh方法，refresh方法就是启动容器的方法
					configureAndRefreshWebApplicationContext(cwac, servletContext);
				}
			}

			//种下上下文信息
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);


			ClassLoader ccl = Thread.currentThread().getContextClassLoader();
			if (ccl == ContextLoader.class.getClassLoader()) {
				currentContext = this.context;
			}
			else if (ccl != null) {
				currentContextPerThread.put(ccl, this.context);
			}

			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
			}
			if (logger.isInfoEnabled()) {
				long elapsedTime = System.currentTimeMillis() - startTime;
				logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
			}

			return this.context;
		}
		catch (RuntimeException ex) {
			logger.error(&quot;Context initialization failed&quot;, ex);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
			throw ex;
		}
		catch (Error err) {
			logger.error(&quot;Context initialization failed&quot;, err);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
			throw err;
		}
	}
}

&lt;/code&gt;
&lt;/pre&gt;

</description>
        <pubDate>Mon, 22 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A62%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/22/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A62%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Spring源码了解</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;下载源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;之前一直停留在应用的阶段，了解的部分也不够全面，这次希望能对spring项目有一个全面的了解。&lt;/p&gt;
&lt;p&gt;spring的项目搭建起来很方便，由于spring依赖gradle,但是你不用事先去下，因为项目下下来之后里面有一键安装的脚本。但是spring4依赖jdk8，如果你想研究spring4的源码，需要事先安装好，我这里介绍的是搭建spring3的，但是后来我还是决定学习spring4的代码，搭建方法是一样的。不影响。&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;下载源码&lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;
&lt;code&gt;
git clone git@github.com:spring-projects/spring-framework.git
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-namexkda&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;安装项目&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;下下来默认是spring4,spring4默认依赖jdk8,（如果你没有jdk8的话）你用里面脚本安装的时候会通不过，因为JVM参数不支持。
你可以选择切换的低版本的分支，或者安装JDK8，我这里选择切换分支。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;查看远程分支&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/showbranch.png&quot; alt=&quot;查看远程分支&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;切换分支&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/switchbranch.png&quot; alt=&quot;切换远程分支&quot; /&gt;&lt;/p&gt;
&lt;p&gt;你会看到这样的目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/list.png&quot; alt=&quot;切换远程分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好，由于我的IDE环境使用的是idea，我们看下import-into-idea.md里面的介绍。eclipse的项目看对应介绍，步骤几乎一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/readme.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好，步骤很清楚了，我们先来执行第一步：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
./gradlew :spring-oxm:compileTestJava cleanIdea idea
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这一步执行起来比较久，得1个多小时，我们慢慢等...&lt;/p&gt;
&lt;p&gt;执行完成，我们open项目&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/import.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择build.gradle&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/build.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击ok&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/ok.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击 open existing project&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/spring/1/exist.png&quot; alt=&quot;readme&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Aug 2016 17:30:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/16/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A61%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/16/Spring-%E6%BA%90%E7%A0%81%E6%B5%85%E5%AD%A61%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍4</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这一次总结的命令是**jinfo**，实际这个命令并不复杂，用的也不多，专门拿一个篇幅总结是想借着这个命令同时总结一下JVM常用的参数&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#Options&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjinfoa&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jinfo命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
Usage:
    jinfo [option] &amp;lt;pid&amp;gt;
        (to connect to running process)
    jinfo [option] &amp;lt;executable &amp;lt;core&amp;gt;
        (to connect to a core file)
    jinfo [option] [server_id@]&amp;lt;remote server IP or hostname&amp;gt;
        (to connect to remote debug server)

where &amp;lt;option&amp;gt; is one of:
    -flag &amp;lt;name&amp;gt;         输出指定JVM参数的值
    -flag [+|-]&amp;lt;name&amp;gt;    启动或者禁用JVM的参数
    -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; 设置JVM参数的值
    -flags               输出所有jvm参数的值
    -sysprops            输出系统属性
    &amp;lt;no option&amp;gt;    输出上面两个属性说有结果
    -h | -help           输出使用用法
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;jinfo--flags-10536&quot;&gt;示例: jinfo -flags 10536&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
部分输出...

Attaching to process ID 10536, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.76-b04

-Dapp.key=hotel.HotelCampaignsWeb -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 
-Djava.io.tmpdir=/tmp -Djava.net.preferIPv6Addresses=false -Xdebug -Xnoagent
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjvm-optionsa&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;常用的jvm options&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;behavioral-options&quot;&gt;Behavioral Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-AllowUserSignalHandlers&lt;/td&gt;
        &lt;td&gt;Do not complain if the application installs signal handlers. (Relevant to Solaris and Linux only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AltStackSize=16384&lt;/td&gt;
        &lt;td&gt;Alternate signal stack size (in Kbytes). (Relevant to Solaris only, removed from 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-DisableExplicitGC&lt;/td&gt;
        &lt;td&gt;By default calls to System.gc() are enabled (-XX:-DisableExplicitGC). Use -XX:+DisableExplicitGC to disable
            calls to System.gc(). Note that the JVM still performs garbage collection when necessary.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+FailOverToOldVerifier&lt;/td&gt;
        &lt;td&gt;Fail over to old verifier when the new type checker fails. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+HandlePromotionFailure&lt;/td&gt;
        &lt;td&gt;The youngest generation collection does not require a guarantee of full promotion of all live objects.
            (Introduced in 1.4.2 update 11) [5.0 and earlier: false.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+MaxFDLimit&lt;/td&gt;
        &lt;td&gt;Bump the number of file descriptors to max. (Relevant&amp;nbsp; to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:PreBlockSpin=10&lt;/td&gt;
        &lt;td&gt;Spin count variable for use with -XX:+UseSpinning. Controls the maximum spin iterations allowed before
            entering operating system thread synchronization code. (Introduced in 1.4.2.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-RelaxAccessControlCheck&lt;/td&gt;
        &lt;td&gt;Relax the access control checks in the verifier. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+ScavengeBeforeFullGC&lt;/td&gt;
        &lt;td&gt;Do young generation GC prior to a full GC. (Introduced in 1.4.1.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseAltSigs&lt;/td&gt;
        &lt;td&gt;Use alternate signals instead of SIGUSR1 and SIGUSR2 for VM internal signals. (Introduced in 1.3.1 update 9,
            1.4.1. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBoundThreads&lt;/td&gt;
        &lt;td&gt;Bind user level threads to kernel threads. (Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseConcMarkSweepGC&lt;/td&gt;
        &lt;td&gt;Use concurrent mark-sweep collection for the old generation. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseGCOverheadLimit&lt;/td&gt;
        &lt;td&gt;Use a policy that limits the proportion of the VM&#39;s time that is spent in GC before an OutOfMemory error is
            thrown. (Introduced in 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLWPSynchronization&lt;/td&gt;
        &lt;td&gt;Use LWP-based instead of thread based synchronization. (Introduced in 1.4.0. Relevant to Solaris only.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for scavenges. (Introduced in 1.4.1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseParallelOldGC&lt;/td&gt;
        &lt;td&gt;Use parallel garbage collection for the full collections. Enabling this option automatically sets
            -XX:+UseParallelGC. (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSerialGC&lt;/td&gt;
        &lt;td&gt;Use serial garbage collection. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseSpinning&lt;/td&gt;
        &lt;td&gt;Enable naive spinning on Java monitor before entering operating system thread synchronizaton code. (Relevant
            to 1.4.2 and 5.0 only.) [1.4.2, multi-processor Windows platforms: true]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseTLAB&lt;/td&gt;
        &lt;td&gt;Use thread-local object allocation (Introduced in 1.4.0, known as UseTLE prior to that.) [1.4.2 and earlier,
            x86 or with -client: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseSplitVerifier&lt;/td&gt;
        &lt;td&gt;Use the new type checker with StackMapTable attributes. (Introduced in 5.0.)[5.0: false]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseThreadPriorities&lt;/td&gt;
        &lt;td&gt;Use native thread priorities.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseVMInterruptibleIO&lt;/td&gt;
        &lt;td&gt;Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. (Introduced in 6. Relevant to
            Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;garbage-first-g1-garbage-collection-options&quot;&gt;Garbage First (G1) Garbage Collection Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseG1GC&lt;/td&gt;
        &lt;td&gt;Use the Garbage First (G1) Collector&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxGCPauseMillis=n&lt;/td&gt;
        &lt;td&gt;Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to
            achieve it.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitiatingHeapOccupancyPercent&lt;span id=&quot;MainContent&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a
            concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A
            value of 0 denotes &#39;do constant GC cycles&#39;. The default value is 45.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. The default value is 2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=n&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size. The default value is 8.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Maximum value for tenuring threshold. The default value is 15.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of threads used during parallel phases of the garbage collectors. The default value varies
            with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ConcGCThreads=n&lt;/td&gt;
        &lt;td&gt;Number of threads concurrent garbage collectors will use. The default value varies with the platform on
            which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1ReservePercent&lt;span id=&quot;MainContent2&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure.
            The default value is 10.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:G1HeapRegionSize&lt;span id=&quot;MainContent3&quot; class=&quot;wcm-region&quot; style=&quot;display: inline&quot;&gt;=n&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual
            sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The
            minimum value is 1Mb and the maximum value is 32Mb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;performance-options&quot;&gt;Performance Options&lt;/h2&gt;
&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AggressiveOpts&lt;/td&gt;
        &lt;td&gt;Turn on point performance compiler optimizations that are expected to be default in upcoming releases.
            (Introduced in 5.0 update 6.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:CompileThreshold=10000&lt;/td&gt;
        &lt;td&gt;Number of method invocations/branches before compiling [-client: 1,500]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LargePageSizeInBytes=4m&lt;/td&gt;
        &lt;td&gt;Sets the large page size used for the Java heap. (Introduced in 1.4.0 update 1.) [amd64: 2m.]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxHeapFreeRatio=70&lt;/td&gt;
        &lt;td&gt;Maximum percentage of heap free after GC to avoid shrinking.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxNewSize=size&lt;/td&gt;
        &lt;td&gt;Maximum size of new generation (in bytes). Since 1.4, MaxNewSize is computed as a function of NewRatio.
            [1.3.1 Sparc: 32m; 1.3.1 x86: 2.5m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxPermSize=64m&lt;/td&gt;
        &lt;td&gt;Size of the Permanent Generation.&amp;nbsp; [5.0 and newer: 64 bit VMs are scaled 30% larger; 1.4 amd64: 96m;
            1.3.1 -client: 32m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MinHeapFreeRatio=40&lt;/td&gt;
        &lt;td&gt;Minimum percentage of heap free after GC to avoid expansion.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewRatio=2&lt;/td&gt;
        &lt;td&gt;Ratio of old/new generation sizes. [Sparc -client: 8; x86 -server: 8; x86 -client: 12.]-client: 4 (1.3) 8
            (1.3.1+), x86: 12]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NewSize=2m&lt;/td&gt;
        &lt;td&gt;Default size of new generation (in bytes) [5.0 and newer: 64 bit VMs are scaled 30% larger; x86: 1m; x86,
            5.0 and older: 640k]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ReservedCodeCacheSize=32m&lt;/td&gt;
        &lt;td&gt;Reserved code cache size (in bytes) - maximum code cache size. [Solaris 64-bit, amd64, and -server x86:
            2048m; in 1.5.0_06 and earlier, Solaris 64-bit and amd64: 1024m.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:SurvivorRatio=8&lt;/td&gt;
        &lt;td&gt;Ratio of eden/survivor space size [Solaris amd64: 6; Sparc in 1.3.1: 25; other Solaris platforms in 5.0 and
            earlier: 32]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:TargetSurvivorRatio=50&lt;/td&gt;
        &lt;td&gt;Desired percentage of survivor space used after scavenge.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ThreadStackSize=512&lt;/td&gt;
        &lt;td&gt;Thread Stack Size (in Kbytes). (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior
            in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseBiasedLocking&lt;/td&gt;
        &lt;td&gt;Enable biased locking. For more details, see this &lt;a href=&quot;/technetwork/java/tuning-139912.html#section4.2.5&quot;&gt;tuning example&lt;/a&gt;. (Introduced in 5.0 update
            6.) [5.0: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
        &lt;td&gt;Use optimized versions of Get&amp;lt;Primitive&amp;gt;Field.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseISM&lt;/td&gt;
        &lt;td&gt;Use Intimate Shared Memory. [Not accepted for non-Solaris platforms.] For details, see &lt;a href=&quot;/technetwork/java/ism-139376.html&quot;&gt;Intimate Shared Memory&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseLargePages&lt;/td&gt;
        &lt;td&gt;Use large page memory. (Introduced in 5.0 update 5.) For details, see &lt;a href=&quot;/technetwork/java/javase/tech/largememory-jsp-137182.html&quot;&gt;Java Support for Large Memory Pages&lt;/a&gt;.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseMPSS&lt;/td&gt;
        &lt;td&gt;Use Multiple Page Size Support w/4mb pages for the heap. Do not use with ISM as this replaces the need for
            ISM. (Introduced in 1.4.0 update 1, Relevant to Solaris 9 and newer.) [1.4.1 and earlier: false]
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseStringCache&lt;/td&gt;
        &lt;td&gt;Enables caching of commonly allocated strings.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchLines=1&lt;/td&gt;
        &lt;td&gt;Number of cache lines to load after the last object allocation using prefetch instructions generated in JIT
            compiled code. Default values are 1 if the last allocated object was an instance and 3 if it was an array.
            &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchStyle=1&lt;/td&gt;
        &lt;td&gt;Generated code style for prefetch instructions.&lt;br /&gt; 0 - no prefetch instructions are generate*d*,&lt;br /&gt; 1 -
            execute prefetch instructions after each allocation,&lt;br /&gt; 2 - use TLAB allocation watermark pointer to gate
            when prefetch instructions are executed.&lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedStrings&lt;/td&gt;
        &lt;td&gt;Use a byte[] for Strings which can be represented as pure ASCII. (Introduced in Java 6 Update 21 Performance
            Release) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
        &lt;td&gt;Optimize String concatenation operations where possible. (Introduced in Java 6 Update 20) &lt;br /&gt; &amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;debugging-options&quot;&gt;Debugging Options&lt;/h2&gt;

&lt;table width=&quot;100%&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; border=&quot;1&quot;&gt;
    &lt;tbody&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;th width=&quot;45%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Option and Default Value&lt;/th&gt;
        &lt;th width=&quot;55%&quot; valign=&quot;top&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-CITime&lt;/td&gt;
        &lt;td&gt;Prints time spent in JIT Compiler. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ErrorFile=./hs_err_pid&amp;lt;pid&amp;gt;.log&lt;/td&gt;
        &lt;td&gt;If an error occurs, save the error data to this file. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-ExtendedDTraceProbes&lt;/td&gt;
        &lt;td&gt;Enable performance-impacting &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/vm/dtrace.html&quot;&gt;dtrace&lt;/a&gt;
            probes. (Introduced in 6. Relevant to Solaris only.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:HeapDumpPath=./java_pid&amp;lt;pid&amp;gt;.hprof&lt;/td&gt;
        &lt;td&gt;Path to directory or filename for heap dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2 update 12, 5.0 update
            7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-HeapDumpOnOutOfMemoryError&lt;/td&gt;
        &lt;td&gt;Dump heap to file when java.lang.OutOfMemoryError is thrown. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2
            update 12, 5.0 update 7.)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnError=&quot;&amp;lt;cmd args&amp;gt;;&amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands on fatal error. (Introduced in 1.4.2 update 9.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:OnOutOfMemoryError=&quot;&amp;lt;cmd args&amp;gt;; &lt;br clear=&quot;none&quot; /&gt; &amp;lt;cmd args&amp;gt;&quot;&lt;/td&gt;
        &lt;td&gt;Run user-defined commands when an OutOfMemoryError is first thrown. (Introduced in 1.4.2 update 12, 6)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintClassHistogram&lt;/td&gt;
        &lt;td&gt;Print a histogram of class instances on Ctrl-Break. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.2.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html&quot;&gt;jmap -histo&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintConcurrentLocks&lt;/td&gt;
        &lt;td&gt;Print java.util.concurrent locks in Ctrl-Break thread dump. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 6.) The &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstack.html&quot;&gt;jstack -l&lt;/a&gt; command
            provides equivalent functionality.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCommandLineFlags&lt;/td&gt;
        &lt;td&gt;Print flags that appeared on the command line. (Introduced in 5.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintCompilation&lt;/td&gt;
        &lt;td&gt;Print message when a method is compiled.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGC&lt;/td&gt;
        &lt;td&gt;Print messages at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCDetails&lt;/td&gt;
        &lt;td&gt;Print more details at garbage collection. &lt;em&gt;Manageable&lt;/em&gt;. (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintGCTimeStamps&lt;/td&gt;
        &lt;td&gt;Print timestamps at garbage collection. &lt;em&gt;Manageable&lt;/em&gt; (Introduced in 1.4.0.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintTenuringDistribution&lt;/td&gt;
        &lt;td&gt;Print tenuring age information.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-PrintAdaptiveSizePolicy&lt;/td&gt;
        &lt;td&gt;Enables printing of information about adaptive generation sizing.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoading&lt;/td&gt;
        &lt;td&gt;Trace loading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassLoadingPreorder&lt;/td&gt;
        &lt;td&gt;Trace all classes loaded in order referenced (not loaded). (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassResolution&lt;/td&gt;
        &lt;td&gt;Trace constant pool resolutions. (Introduced in 1.4.2.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceClassUnloading&lt;/td&gt;
        &lt;td&gt;Trace unloading of classes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-TraceLoaderConstraints&lt;/td&gt;
        &lt;td&gt;Trace recording of loader constraints. (Introduced in 6.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+PerfDataSaveToFile&lt;/td&gt;
        &lt;td&gt;Saves jvmstat binary data on exit.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:ParallelGCThreads=n&lt;/td&gt;
        &lt;td&gt;Sets the number of garbage collection threads in the young and old parallel garbage collectors. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+UseCompressedOops&lt;/td&gt;
        &lt;td&gt;Enables the use of compressed pointers (object references represented as 32 bit offsets instead of 64-bit
            pointers) for optimized 64-bit performance with Java heap sizes less than 32gb.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
        &lt;td&gt;Pre-touch the Java heap during JVM initialization. Every page of the heap is thus demand-zeroed during
            initialization rather than incrementally during application execution.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:AllocatePrefetchDistance=n&lt;/td&gt;
        &lt;td&gt;Sets the prefetch distance for object allocation. Memory about to be written with the value of new objects
            is prefetched into cache at this distance (in bytes) beyond the address of the last allocated object. Each
            Java thread has its own allocation point. The default value varies with the platform on which the JVM is
            running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InlineSmallCode=n&lt;/td&gt;
        &lt;td&gt;Inline a previously compiled method only if its generated native code size is less than this. The default
            value varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxInlineSize=35&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a method to be inlined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:FreqInlineSize=n&lt;/td&gt;
        &lt;td&gt;Maximum bytecode size of a frequently executed method to be inlined. The default value varies with the
            platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:LoopUnrollLimit=n&lt;/td&gt;
        &lt;td&gt;Unroll loop bodies with server compiler intermediate representation node count less than this value. The
            limit used by the server compiler is a function of this value, not the actual value. The default value
            varies with the platform on which the JVM is running.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:InitialTenuringThreshold=7&lt;/td&gt;
        &lt;td&gt;Sets the initial tenuring threshold for use in adaptive GC sizing in the parallel young collector. The
            tenuring threshold is the number of times an object survives a young collection before being promoted to the
            old, or tenured, generation.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:MaxTenuringThreshold=n&lt;/td&gt;
        &lt;td&gt;Sets the maximum tenuring threshold for use in adaptive GC sizing. The current largest value is 15. The
            default value is 15 for the parallel collector and is 4 for CMS.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-Xloggc:&amp;lt;filename&amp;gt;&lt;/td&gt;
        &lt;td&gt;Log GC verbose output to specified file. The verbose output is controlled by the normal verbose GC flags.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:-UseGCLogFileRotation&lt;/td&gt;
        &lt;td&gt;Enabled GC log rotation, requires -Xloggc.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:NumberOfGClogFiles=1&lt;/td&gt;
        &lt;td&gt;Set the number of files to use when rotating logs, must be &amp;gt;= 1. The rotated log files will use the
            following naming scheme, &amp;lt;filename&amp;gt;.0, &amp;lt;filename&amp;gt;.1, ..., &amp;lt;filename&amp;gt;.n-1.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr valign=&quot;top&quot;&gt;
        &lt;td&gt;-XX:GCLogFileSize=8K&lt;/td&gt;
        &lt;td&gt;The size of the log file at which point the log will be rotated, must be &amp;gt;= 8K.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D4/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>JDK-命令行工具介绍3</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstat -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstat&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstata&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstat命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack jvm监控统计工具-可以用于观察jvm运行时区域的数据&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dunnohe.github.io/img/jstat/jstat.png&quot; alt=&quot;jstat_输出&quot; /&gt;
一张图理解用法&lt;/p&gt;

&lt;h2 id=&quot;options&quot;&gt;options&lt;/h2&gt;
&lt;p&gt;使用jstat -options可以查看支持的选项&lt;/p&gt;

&lt;p&gt;$ jstat -options&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-class 显示classLoader的相关信息&lt;/li&gt;
  &lt;li&gt;-compiler 显示JIT编译的相关信息&lt;/li&gt;
  &lt;li&gt;-gc 显示gc相关信息&lt;/li&gt;
  &lt;li&gt;-gccapacity 显示gc容量信息&lt;/li&gt;
  &lt;li&gt;-gccause 显示垃圾回收相关信息，同时显示最后一次或者当前正在发生的垃圾回收的诱发原因&lt;/li&gt;
  &lt;li&gt;-gcnew 显示新生代信息&lt;/li&gt;
  &lt;li&gt;-gcnewcapacity 显示新生代容量和大小情况&lt;/li&gt;
  &lt;li&gt;-gcold 显示老年代和永久代情况&lt;/li&gt;
  &lt;li&gt;-gcoldcapacity 显示老年代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcpermcapacity 显示永久代大小和容量信息&lt;/li&gt;
  &lt;li&gt;-gcutil 显示垃圾收集信息（这个用的最多）&lt;/li&gt;
  &lt;li&gt;-printcompilation 输出JIT编辑的方法信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-nametcyjstat--gcutil-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstat -gcutil 输出解释&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;更多解释请看http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们这里介绍一下用的最多的命令的输出&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
       413446.8  40.62   0.00  58.40  36.91      -      -    174   17.153     1    1.798   18.952
       413447.8  40.62   0.00  58.51  36.91      -      -    174   17.153     1    1.798   18.952
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;S0 S0占对应分配空间的利用百分比（理解S0,S1需要关注一下垃圾回收算法）&lt;/li&gt;
  &lt;li&gt;S1 S1占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;E	新生代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;O	老年代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;P	永久代占对应分配空间的利用百分比&lt;/li&gt;
  &lt;li&gt;YGC	young gc的次数&lt;/li&gt;
  &lt;li&gt;YGCT	young gc花费的时间&lt;/li&gt;
  &lt;li&gt;FGC	full gc次数&lt;/li&gt;
  &lt;li&gt;FGCT	full gc花费的时间&lt;/li&gt;
  &lt;li&gt;GCT	Total garbage collection time.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 02:58:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/08/02/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D3/</guid>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>Jdk 命令行工具介绍2</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout:     post
title:      “JDK-命令行工具介绍2”
subtitle:   “ &quot;了解jstack的用法&quot;”
date:       2016-07-31 18:58:00
author:     “Dunno”
header-img: “img/post-bg-2015.jpg”
tags:
    - JVM
—&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#js&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-namejsa&quot;&gt;&lt;a name=&quot;js&quot;&gt;背景介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;线上经常出现各式各样的问题，通过jdk自带的命令行工具，能帮助我们更加快速的定位到故障。&lt;/p&gt;
&lt;p&gt;jdk 为我们提供了很多命令行工具，其中经常使用到的有监控工具（jps,jstat,statd）和故障排查工具(jinfo,jhat,jmap,jsadebugd,jstack)
&lt;/p&gt;
&lt;p&gt;这次我们介绍非常非常常用的命令：jstack&lt;/p&gt;

&lt;h1 id=&quot;a-nameckzla&quot;&gt;&lt;a name=&quot;ckzl&quot;&gt;参考资料&lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/
https://dzone.com/articles/how-analyze-java-thread-dumps
https://gist.github.com/rednaxelafx/843622&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;a-namexkdjstacka&quot;&gt;&lt;a name=&quot;xkd&quot;&gt;jstack命令介绍&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;jstack 根据指定的端口或者远程debug服务打印出线程栈跟踪信息。&lt;/p&gt;

&lt;h2 id=&quot;jstack--l-7124-pid7124&quot;&gt;jstack -l 7124 打出pid为7124的线程栈跟踪信息&lt;/h2&gt;

&lt;p&gt;部分输出:&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.76-b04 mixed mode):

&amp;quot;Thread-11-EventThread&amp;quot; daemon prio=5 tid=0x00007f8e9d8e0000 nid=0x32327 waiting on condition [0x0000700013bca000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  &amp;lt;0x00000007eef76740&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:494)

   Locked ownable synchronizers:
	- None

&amp;quot;Thread-11-SendThread(10.4.241.128:2181)&amp;quot; daemon prio=5 tid=0x00007f8e9d857000 nid=0x2a33f runnable [0x0000700013ac7000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:200)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
	- locked &amp;lt;0x00000007eef75488&amp;gt; (a sun.nio.ch.Util$2)
	- locked &amp;lt;0x00000007eef75478&amp;gt; (a java.util.Collections$UnmodifiableSet)
	- locked &amp;lt;0x00000007eef75358&amp;gt; (a sun.nio.ch.KQueueSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
	at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:349)
	at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1081)

   Locked ownable synchronizers:
	- None
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&quot;a-nametcyjstack--l-a&quot;&gt;&lt;a name=&quot;tcy&quot;&gt;jstack -l 输出解释&lt;/a&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;“Thread-11-EventThread”&lt;/strong&gt; 线程名字，当使用Thread类生成的线程，thread会被命名成Thread-(Number)，而使用ThreadFactory类生成的线程会被命名成pool-(number)-thread-(number)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt; 如果有这一列代表是守护线程，没有则说明不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;prio=5&lt;/strong&gt; 代表该线程的权值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tid=0x00007f8e9d857000&lt;/strong&gt; 代表该线程唯一的id（线程id），这个id是java层面的id&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nid=0x2a33f&lt;/strong&gt; 本地线程id(Native thread ID)，这个id的值依赖于系统平台层面。
    &lt;ul&gt;
      &lt;li&gt;windows下，就是操作系统级别的线程id&lt;/li&gt;
      &lt;li&gt;Linux下，nid是线程的pid （这里多提一句，我们大多场景是在linux上，当出现问题时，我们先可以利用 top -Hp 找出不正常的线程pid，把pid转成16进制（因为nid是16进制），然后根据这个转好的pid立马找到线程在干嘛，通常就能发现问题，top的用法，可以回滚之前的top使用的总结。 ）&lt;/li&gt;
      &lt;li&gt;Solaris下，nid是thr_self()的返回值&lt;/li&gt;
      &lt;li&gt;在Mac OS下，可以认为是本地pthread_t的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;waiting on condition [0x0000700013bca000] / runnable [0x0000700013ac7000]&lt;/strong&gt; 线程此时的状态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最后一栏&lt;/strong&gt; 代表线程调用的完整的堆栈信息&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</link>
        <guid isPermaLink="true">http://dunnohe.github.io/2016/07/31/JDK-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D2/</guid>
        
        
      </item>
    
  </channel>
</rss>
